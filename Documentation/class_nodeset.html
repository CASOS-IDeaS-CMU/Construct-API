<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Construct: Nodeset Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_dark.png"/></td>
  <td id="projectalign">
   <div id="projectname">Construct<span id="projectnumber">&#160;version 5.2.2</span>
   </div>
   <div id="projectbrief">An agent based modeling framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_nodeset.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_nodeset-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Nodeset Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A container for nodes.  
 <a href="class_nodeset.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3ae37f085c4a4278ae78efb84b461fa"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nodeset.html#ac3ae37f085c4a4278ae78efb84b461fa">begin</a> (void) const</td></tr>
<tr class="memdesc:ac3ae37f085c4a4278ae78efb84b461fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing the beginning of the vector of nodes.  <a href="class_nodeset.html#ac3ae37f085c4a4278ae78efb84b461fa">More...</a><br /></td></tr>
<tr class="separator:ac3ae37f085c4a4278ae78efb84b461fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3410c8dc6dec8210e7d8fd83593cf12"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nodeset.html#ac3410c8dc6dec8210e7d8fd83593cf12">end</a> (void) const</td></tr>
<tr class="memdesc:ac3410c8dc6dec8210e7d8fd83593cf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing the beyond the last node in the vector of nodes.  <a href="class_nodeset.html#ac3410c8dc6dec8210e7d8fd83593cf12">More...</a><br /></td></tr>
<tr class="separator:ac3410c8dc6dec8210e7d8fd83593cf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa078150cc61ae3ae9a8752c50639c7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nodeset.html#a4fa078150cc61ae3ae9a8752c50639c7">size</a> (void) const</td></tr>
<tr class="memdesc:a4fa078150cc61ae3ae9a8752c50639c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the nodeset  <a href="class_nodeset.html#a4fa078150cc61ae3ae9a8752c50639c7">More...</a><br /></td></tr>
<tr class="separator:a4fa078150cc61ae3ae9a8752c50639c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb67700279b1308b51eeb3c07b64c3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a> (const <a class="el" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a> *attributes)</td></tr>
<tr class="memdesc:a5eb67700279b1308b51eeb3c07b64c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the <a class="el" href="class_nodeset.html" title="A container for nodes.">Nodeset</a>.  <a href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">More...</a><br /></td></tr>
<tr class="separator:a5eb67700279b1308b51eeb3c07b64c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b9fa1c866672933a0fbb1d6f36e6c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nodeset.html#ae6b9fa1c866672933a0fbb1d6f36e6c1">add_node</a> (const std::string &amp;node_name, const <a class="el" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a> *attributes)</td></tr>
<tr class="memdesc:ae6b9fa1c866672933a0fbb1d6f36e6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the <a class="el" href="class_nodeset.html" title="A container for nodes.">Nodeset</a>.  <a href="class_nodeset.html#ae6b9fa1c866672933a0fbb1d6f36e6c1">More...</a><br /></td></tr>
<tr class="separator:ae6b9fa1c866672933a0fbb1d6f36e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b35cb69f479d48c076330b54cbcad6e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nodeset.html#a7b35cb69f479d48c076330b54cbcad6e">get_node_by_index</a> (unsigned int index) const</td></tr>
<tr class="memdesc:a7b35cb69f479d48c076330b54cbcad6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a node using the node's index.  <a href="class_nodeset.html#a7b35cb69f479d48c076330b54cbcad6e">More...</a><br /></td></tr>
<tr class="separator:a7b35cb69f479d48c076330b54cbcad6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8096d59927fe1e3fb7c803d1d87ac46e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nodeset.html#a8096d59927fe1e3fb7c803d1d87ac46e">get_node_by_name</a> (const std::string &amp;<a class="el" href="class_nodeset.html#a59ee2255cdc2b09f495448e3f8bf307e">name</a>) const</td></tr>
<tr class="memdesc:a8096d59927fe1e3fb7c803d1d87ac46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a node using the node's name.  <a href="class_nodeset.html#a8096d59927fe1e3fb7c803d1d87ac46e">More...</a><br /></td></tr>
<tr class="separator:a8096d59927fe1e3fb7c803d1d87ac46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac3c4f4f11ffa9836496730f43fc56f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ac3c4f4f11ffa9836496730f43fc56f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nodeset.html#a3ac3c4f4f11ffa9836496730f43fc56f">check_attributes</a> (std::string attribute, T min, T max) const</td></tr>
<tr class="memdesc:a3ac3c4f4f11ffa9836496730f43fc56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that all nodes in the nodeset for the specified attribute.  <a href="class_nodeset.html#a3ac3c4f4f11ffa9836496730f43fc56f">More...</a><br /></td></tr>
<tr class="separator:a3ac3c4f4f11ffa9836496730f43fc56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b6e3715a1dab8c930c9ab720e27418"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5b6e3715a1dab8c930c9ab720e27418"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nodeset.html#ab5b6e3715a1dab8c930c9ab720e27418">check_attributes</a> (std::string attribute) const</td></tr>
<tr class="memdesc:ab5b6e3715a1dab8c930c9ab720e27418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that all nodes in the nodeset for the specified attribute.  <a href="class_nodeset.html#ab5b6e3715a1dab8c930c9ab720e27418">More...</a><br /></td></tr>
<tr class="separator:ab5b6e3715a1dab8c930c9ab720e27418"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a59ee2255cdc2b09f495448e3f8bf307e"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nodeset.html#a59ee2255cdc2b09f495448e3f8bf307e">name</a></td></tr>
<tr class="separator:a59ee2255cdc2b09f495448e3f8bf307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A container for nodes. </p>
<p >A nodeset is a container for <a class="el" href="class_node.html" title="Nodes are any type of entity with or without attributes.">Node</a>s. This includes basic functions for accessing and interacting with the nodes in the nodeset.</p>
<p >Nodesets are created by the <a class="el" href="class_nodeset_manager.html" title="A container for nodesets.">NodesetManager</a>. It is not expected that other classes in <a class="el" href="class_construct.html" title="The API class that coordinates the transfer of information between classes.">Construct</a> would create a nodeset. Rather a pointer to an existing nodeset to find a node is the primary way a nodeset is used. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5eb67700279b1308b51eeb3c07b64c3e" name="a5eb67700279b1308b51eeb3c07b64c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb67700279b1308b51eeb3c07b64c3e">&#9670;&nbsp;</a></span>add_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Nodeset::add_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a> *&#160;</td>
          <td class="paramname"><em>attributes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a node to the <a class="el" href="class_nodeset.html" title="A container for nodes.">Nodeset</a>. </p>
<p >Nodes are added to the nodeset with index equal to the previous nodeset size. The nodes name is created using the nodeset's name plus the node's index. If the submitted pointer is added to the nodeset, the nodeset assumes ownership of the pointer and will deallocate when its deconstructor is called. Ownership not being passed to the nodeset happens when the node attribute's contents equals the previous node attribute's contents, but have differing pointers. Pointers whose ownership is not transferred over should be deallocated using delete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td>A pointer to the node attributes to be added. This pointer should allocated using new. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the pointer ownership was not transferred the nodeset and should be deallocated, and false otherwise. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_nodeset.html">Nodeset</a>* my_nodeset = construct-&gt;ns_manager-&gt;create_nodeset(<span class="stringliteral">&quot;my_nodeset&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a>* my_attributes = <span class="keyword">new</span> <a class="code hl_typedef" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a>();</div>
<div class="line">    my_attributes-&gt;insert(std::make_pair(<span class="stringliteral">&quot;my att1 name&quot;</span>, <span class="stringliteral">&quot;my att1 value&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//At this point we know that the nodeset will take ownership of the submitted attribute pointer</span></div>
<div class="line">    <span class="comment">//This is because only one pointer has been submitted in the nodeset&#39;s history.</span></div>
<div class="line"> </div>
<div class="line">    my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(<span class="stringliteral">&quot;Mary&quot;</span>, my_attributes);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Once the nodeset takes ownership of the pointer, it can be repeatedly submitted to the function.</span></div>
<div class="line"> </div>
<div class="line">    my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(<span class="stringliteral">&quot;Joe&quot;</span>, my_attributes);</div>
<div class="line"> </div>
<div class="line">    my_attributes = <span class="keyword">new</span> <a class="code hl_typedef" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a>();</div>
<div class="line">    my_attributes-&gt;insert(std::make_pair(<span class="stringliteral">&quot;my att1 name&quot;</span>, <span class="stringliteral">&quot;my att1 value&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//because the nodeset will attempt to optimize memory usage, it will reject ownership of this pointer</span></div>
<div class="line">    <span class="comment">//as its contents are equal to the previous node&#39;s (Joe) attributes.</span></div>
<div class="line">    <span class="comment">//The nodeset will then use that attribute pointer rather than the submitted pointer.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(<span class="stringliteral">&quot;John&quot;</span>, my_attributes)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;attribute pointer not added and requires deallocation&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keyword">delete</span> my_attributes;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    my_attributes = <span class="keyword">new</span> <a class="code hl_typedef" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a>();</div>
<div class="line">    my_attributes-&gt;insert(std::make_pair(<span class="stringliteral">&quot;my att2 name&quot;</span>, <span class="stringliteral">&quot;my att2 value&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//if you&#39;re sure the nodeset will not reject ownership you need not check each function return</span></div>
<div class="line"> </div>
<div class="line">    my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(<span class="stringliteral">&quot;Rebecca&quot;</span>, my_attributes);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//any previous pointer that the nodeset has taken ownership of can be used with a check on the function return</span></div>
<div class="line">    <span class="comment">//if no name is given a unique name is given based on the nodeset name and the node&#39;s index</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> first_node = my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#ac3ae37f085c4a4278ae78efb84b461fa">begin</a>();</div>
<div class="line">    my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(it-&gt;attributes);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> node = my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#ac3ae37f085c4a4278ae78efb84b461fa">begin</a>(); node != my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#ac3410c8dc6dec8210e7d8fd83593cf12">end</a>(); ++node) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Node name, index: &quot;</span> &lt;&lt; node-&gt;name &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::to_string(node-&gt;index) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Node attributes:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> att = node-&gt;attributes-&gt;begin(); att != node-&gt;attributes-&gt;end(); ++att) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;/t&quot;</span> &lt;&lt; att-&gt;first &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; att-&gt;second &lt;&lt; std::endl; </div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclass_nodeset_html"><div class="ttname"><a href="class_nodeset.html">Nodeset</a></div><div class="ttdoc">A container for nodes.</div><div class="ttdef"><b>Definition:</b> NodesetManager.h:163</div></div>
<div class="ttc" id="aclass_nodeset_html_a5eb67700279b1308b51eeb3c07b64c3e"><div class="ttname"><a href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">Nodeset::add_node</a></div><div class="ttdeci">bool add_node(const dynet::ParameterMap *attributes)</div><div class="ttdoc">Adds a node to the Nodeset.</div><div class="ttdef"><b>Definition:</b> NodesetManager.cpp:18</div></div>
<div class="ttc" id="aclass_nodeset_html_ac3410c8dc6dec8210e7d8fd83593cf12"><div class="ttname"><a href="class_nodeset.html#ac3410c8dc6dec8210e7d8fd83593cf12">Nodeset::end</a></div><div class="ttdeci">iterator end(void) const</div><div class="ttdoc">Returns an iterator pointing the beyond the last node in the vector of nodes.</div><div class="ttdef"><b>Definition:</b> NodesetManager.cpp:11</div></div>
<div class="ttc" id="aclass_nodeset_html_ac3ae37f085c4a4278ae78efb84b461fa"><div class="ttname"><a href="class_nodeset.html#ac3ae37f085c4a4278ae78efb84b461fa">Nodeset::begin</a></div><div class="ttdeci">iterator begin(void) const</div><div class="ttdoc">Returns an iterator pointing the beginning of the vector of nodes.</div><div class="ttdef"><b>Definition:</b> NodesetManager.cpp:10</div></div>
<div class="ttc" id="anamespacedynet_html_a34559dfdfab68c9dd4735fbea126387b"><div class="ttname"><a href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a></div><div class="ttdeci">std::unordered_map&lt; std::string, std::string &gt; ParameterMap</div><div class="ttdoc">Defining this as a string to string map.</div><div class="ttdef"><b>Definition:</b> utils.h:93</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Node name, index: Mary, 0
Node attributes:
    my att1 name -&gt; my att1 value
Node name, index: Joe, 1
Node attributes:
    my att1 name -&gt; my att1 value
Node name, index: John, 2
Node attributes:
    my att1 name -&gt; my att1 value
Node name, index: Rebecca, 3
Node attributes:
    my att2 name -&gt; my att2 value
Node name, index: my_nodeset_4, 4
Node attributes:
    my att1 name -&gt; my att1 value
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >If a reallocation happens, all iterators, pointers and references related to the container are invalidated. Otherwise, only the end iterator is invalidated, and all iterators, pointers and references to elements are guaranteed to keep referring to the same elements they were referring to before the call.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if the submitted ParameterMap pointer is a NULL pointer or if the nodeset has been turned to a constant nodeset.</p>
<p >An exception is thrown if the created node name (nodeset name + "_" + index) matches any previous node name. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_nodeset_a5eb67700279b1308b51eeb3c07b64c3e_cgraph.png" border="0" usemap="#aclass_nodeset_a5eb67700279b1308b51eeb3c07b64c3e_cgraph" alt=""/></div>
<map name="aclass_nodeset_a5eb67700279b1308b51eeb3c07b64c3e_cgraph" id="aclass_nodeset_a5eb67700279b1308b51eeb3c07b64c3e_cgraph">
<area shape="rect" title="Adds a node to the Nodeset." alt="" coords="5,29,140,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_nodeset_a5eb67700279b1308b51eeb3c07b64c3e_icgraph.png" border="0" usemap="#aclass_nodeset_a5eb67700279b1308b51eeb3c07b64c3e_icgraph" alt=""/></div>
<map name="aclass_nodeset_a5eb67700279b1308b51eeb3c07b64c3e_icgraph" id="aclass_nodeset_a5eb67700279b1308b51eeb3c07b64c3e_icgraph">
<area shape="rect" title="Adds a node to the Nodeset." alt="" coords="5,29,140,56"/>
</map>
</div>

</div>
</div>
<a id="ae6b9fa1c866672933a0fbb1d6f36e6c1" name="ae6b9fa1c866672933a0fbb1d6f36e6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b9fa1c866672933a0fbb1d6f36e6c1">&#9670;&nbsp;</a></span>add_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Nodeset::add_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a> *&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a node to the <a class="el" href="class_nodeset.html" title="A container for nodes.">Nodeset</a>. </p>
<p >Nodes are added to the nodeset with index equal to the previous nodeset size. The nodes name is created using the nodeset's name plus the node's index. If the submitted pointer is added to the nodeset, the nodeset assumes ownership of the pointer and will deallocate when its deconstructor is called. Ownership not being passed to the nodeset happens when the node attribute's contents equals the previous node attribute's contents, but have differing pointers. Pointers whose ownership is not transferred over should be deallocated using delete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_name</td><td>Name of the node to be added to the end of the <a class="el" href="class_nodeset.html" title="A container for nodes.">Nodeset</a>. </td></tr>
    <tr><td class="paramname">attributes</td><td>A pointer to the node attributes to be added. This pointer should allocated using new. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the pointer ownership was not transferred the nodeset and should be deallocated, and false otherwise. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_nodeset.html">Nodeset</a>* my_nodeset = construct-&gt;ns_manager-&gt;create_nodeset(<span class="stringliteral">&quot;my_nodeset&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a>* my_attributes = <span class="keyword">new</span> <a class="code hl_typedef" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a>();</div>
<div class="line">    my_attributes-&gt;insert(std::make_pair(<span class="stringliteral">&quot;my att1 name&quot;</span>, <span class="stringliteral">&quot;my att1 value&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//At this point we know that the nodeset will take ownership of the submitted attribute pointer</span></div>
<div class="line">    <span class="comment">//This is because only one pointer has been submitted in the nodeset&#39;s history.</span></div>
<div class="line"> </div>
<div class="line">    my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(<span class="stringliteral">&quot;Mary&quot;</span>, my_attributes);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Once the nodeset takes ownership of the pointer, it can be repeatedly submitted to the function.</span></div>
<div class="line"> </div>
<div class="line">    my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(<span class="stringliteral">&quot;Joe&quot;</span>, my_attributes);</div>
<div class="line"> </div>
<div class="line">    my_attributes = <span class="keyword">new</span> <a class="code hl_typedef" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a>();</div>
<div class="line">    my_attributes-&gt;insert(std::make_pair(<span class="stringliteral">&quot;my att1 name&quot;</span>, <span class="stringliteral">&quot;my att1 value&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//because the nodeset will attempt to optimize memory usage, it will reject ownership of this pointer</span></div>
<div class="line">    <span class="comment">//as its contents are equal to the previous node&#39;s (Joe) attributes.</span></div>
<div class="line">    <span class="comment">//The nodeset will then use that attribute pointer rather than the submitted pointer.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(<span class="stringliteral">&quot;John&quot;</span>, my_attributes)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;attribute pointer not added and requires deallocation&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keyword">delete</span> my_attributes;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    my_attributes = <span class="keyword">new</span> <a class="code hl_typedef" href="namespacedynet.html#a34559dfdfab68c9dd4735fbea126387b">dynet::ParameterMap</a>();</div>
<div class="line">    my_attributes-&gt;insert(std::make_pair(<span class="stringliteral">&quot;my att2 name&quot;</span>, <span class="stringliteral">&quot;my att2 value&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//if you&#39;re sure the nodeset will not reject ownership you need not check each function return</span></div>
<div class="line"> </div>
<div class="line">    my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(<span class="stringliteral">&quot;Rebecca&quot;</span>, my_attributes);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//any previous pointer that the nodeset has taken ownership of can be used with a check on the function return</span></div>
<div class="line">    <span class="comment">//if no name is given a unique name is given based on the nodeset name and the node&#39;s index</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> first_node = my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#ac3ae37f085c4a4278ae78efb84b461fa">begin</a>();</div>
<div class="line">    my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#a5eb67700279b1308b51eeb3c07b64c3e">add_node</a>(it-&gt;attributes);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> node = my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#ac3ae37f085c4a4278ae78efb84b461fa">begin</a>(); node != my_nodeset-&gt;<a class="code hl_function" href="class_nodeset.html#ac3410c8dc6dec8210e7d8fd83593cf12">end</a>(); ++node) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Node name, index: &quot;</span> &lt;&lt; node-&gt;name &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::to_string(node-&gt;index) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Node attributes:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> att = node-&gt;attributes-&gt;begin(); att != node-&gt;attributes-&gt;end(); ++att) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;/t&quot;</span> &lt;&lt; att-&gt;first &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; att-&gt;second &lt;&lt; std::endl; </div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Node name, index: Mary, 0
Node attributes:
    my att1 name -&gt; my att1 value
Node name, index: Joe, 1
Node attributes:
    my att1 name -&gt; my att1 value
Node name, index: John, 2
Node attributes:
    my att1 name -&gt; my att1 value
Node name, index: Rebecca, 3
Node attributes:
    my att2 name -&gt; my att2 value
Node name, index: my_nodeset_4, 4
Node attributes:
    my att1 name -&gt; my att1 value
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >If a reallocation happens, all iterators, pointers and references related to the container are invalidated. Otherwise, only the end iterator is invalidated, and all iterators, pointers and references to elements are guaranteed to keep referring to the same elements they were referring to before the call.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if the submitted ParameterMap pointer is a NULL pointer or if the nodeset has been turned to a constant nodeset.</p>
<p >An exception is thrown if the submitted node_name matches any previous node name. </p>

</div>
</div>
<a id="ac3ae37f085c4a4278ae78efb84b461fa" name="ac3ae37f085c4a4278ae78efb84b461fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ae37f085c4a4278ae78efb84b461fa">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nodeset::iterator Nodeset::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing the beginning of the vector of nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>A random access iterator pointing to the first node in the nodeset. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//nodeset has been preloaded with some agents; Mary, John, and Joe.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_nodeset.html">Nodeset</a>* agents = construct-&gt;get_NodesetManager()-&gt;get_nodeset(nodeset_names::agent);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;This nodeset conatins:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span>(Nodeset::iterator it = agents-&gt;begin(); it != agents-&gt;end(); ++it) {</div>
<div class="line">        std::cout &lt;&lt; it-&gt;name &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">This nodeset contains:
Mary
John
Joe
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes</p>
<p ><b>Exception Safety</b></p>
<p >No-throw guarantee: this member function never throws exceptions. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_nodeset_ac3ae37f085c4a4278ae78efb84b461fa_icgraph.png" border="0" usemap="#aclass_nodeset_ac3ae37f085c4a4278ae78efb84b461fa_icgraph" alt=""/></div>
<map name="aclass_nodeset_ac3ae37f085c4a4278ae78efb84b461fa_icgraph" id="aclass_nodeset_ac3ae37f085c4a4278ae78efb84b461fa_icgraph">
<area shape="rect" title="Returns an iterator pointing the beginning of the vector of nodes." alt="" coords="180,5,289,32"/>
<area shape="rect" href="class_location.html#a22fe41e44e3f9c730a0567e027d574b8" title="Function called once before any simulation cycles begin." alt="" coords="5,5,132,32"/>
</map>
</div>

</div>
</div>
<a id="ab5b6e3715a1dab8c930c9ab720e27418" name="ab5b6e3715a1dab8c930c9ab720e27418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b6e3715a1dab8c930c9ab720e27418">&#9670;&nbsp;</a></span>check_attributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Nodeset::check_attributes </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>attribute</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that all nodes in the nodeset for the specified attribute. </p>
<p >The attribute values are converted to the data type dictated the explicit instantiation of the template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>Name of the attribute that each node should have. </td></tr>
  </table>
  </dd>
</dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_nodeset.html">Nodeset</a>* ns = _construct-&gt;getNodesetManager()-&gt;get_nodeset(<span class="stringliteral">&quot;ns&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// following node has been loaded into the nodeset &quot;ns&quot; with the following attributes</span></div>
<div class="line">    <span class="comment">// &lt;node name=&quot;node1&quot;&gt;</span></div>
<div class="line">    <span class="comment">//  &lt;attribute name=&quot;attribute1&quot; value=&quot;0.5&quot;/&gt;</span></div>
<div class="line">    <span class="comment">//  &lt;attribute name=&quot;attribute2&quot; value=&quot;-2&quot;/&gt;</span></div>
<div class="line">    <span class="comment">// &lt;/node&gt;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        ns-&gt;<a class="code hl_function" href="class_nodeset.html#a3ac3c4f4f11ffa9836496730f43fc56f">check_attributes</a>&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;attribute1&quot;</span>);</div>
<div class="line">        ns-&gt;<a class="code hl_function" href="class_nodeset.html#a3ac3c4f4f11ffa9836496730f43fc56f">check_attributes</a>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;attribute2&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::string e) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_nodeset_html_a3ac3c4f4f11ffa9836496730f43fc56f"><div class="ttname"><a href="class_nodeset.html#a3ac3c4f4f11ffa9836496730f43fc56f">Nodeset::check_attributes</a></div><div class="ttdeci">void check_attributes(std::string attribute, T min, T max) const</div><div class="ttdoc">Checks that all nodes in the nodeset for the specified attribute.</div><div class="ttdef"><b>Definition:</b> NodesetManager.cpp:240</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Error: Could not convert value to unsigned int for attribute "attribute2" for node "node1". </pre> <p ><b>Complexity</b></p>
<p >Linear in number of nodes in the specified nodeset.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >A string exception is thrown if an attribute can not be converted to the explicit value type. </p>

</div>
</div>
<a id="a3ac3c4f4f11ffa9836496730f43fc56f" name="a3ac3c4f4f11ffa9836496730f43fc56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac3c4f4f11ffa9836496730f43fc56f">&#9670;&nbsp;</a></span>check_attributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Nodeset::check_attributes </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that all nodes in the nodeset for the specified attribute. </p>
<p >These attributes are converted to the type determined by the submitted parameters. The converted values are then checked to ensure the it lies between the submitted bounds for that attribute. The only template instantiations available are int, unsigned int, float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>Name of the attribute that each node should have. </td></tr>
    <tr><td class="paramname">min</td><td>The minimum value the attribute can have. Any attribute value that is smaller than <em>min</em> will cause a string exception to be thrown. </td></tr>
    <tr><td class="paramname">max</td><td>The maximum value the attribute can have. Any attribute value that is greater than <em>max</em> will cause a string exception to be thrown. </td></tr>
  </table>
  </dd>
</dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_nodeset.html">Nodeset</a>* ns = _construct-&gt;getNodesetManager()-&gt;get_nodeset(<span class="stringliteral">&quot;ns&quot;</span>); </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// following node has been loaded into the nodeset &quot;ns&quot; with the following attributes</span></div>
<div class="line">    <span class="comment">// &lt;node name=&quot;node1&quot;&gt;</span></div>
<div class="line">    <span class="comment">//  &lt;attribute name=&quot;attribute1&quot; value=&quot;0.5&quot;/&gt;</span></div>
<div class="line">    <span class="comment">//  &lt;attribute name=&quot;attribute2&quot; value=&quot;2&quot;/&gt;</span></div>
<div class="line">    <span class="comment">// &lt;/node&gt;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        ns-&gt;<a class="code hl_function" href="class_nodeset.html#a3ac3c4f4f11ffa9836496730f43fc56f">check_attributes</a>(<span class="stringliteral">&quot;attribute1&quot;</span>, 0.0f, 1.0f);</div>
<div class="line">        ns-&gt;<a class="code hl_function" href="class_nodeset.html#a3ac3c4f4f11ffa9836496730f43fc56f">check_attributes</a>(<span class="stringliteral">&quot;attribute2&quot;</span>, 0, 1);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::string e) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Error: "attribute2" for node "node1" is out of range [0,1]. </pre> <p ><b>Complexity</b></p>
<p >Linear in number of nodes in the specified nodeset.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >A string exception is thrown if an attribute can not be converted to the value type. A string exception is also thrown if the converted value is outside the the specified bounds. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_nodeset_a3ac3c4f4f11ffa9836496730f43fc56f_cgraph.png" border="0" usemap="#aclass_nodeset_a3ac3c4f4f11ffa9836496730f43fc56f_cgraph" alt=""/></div>
<map name="aclass_nodeset_a3ac3c4f4f11ffa9836496730f43fc56f_cgraph" id="aclass_nodeset_a3ac3c4f4f11ffa9836496730f43fc56f_cgraph">
<area shape="rect" title="Checks that all nodes in the nodeset for the specified attribute." alt="" coords="5,5,180,32"/>
<area shape="rect" href="namespacedynet.html#a7acc13a9502ddba7144d2022be86c949" title="Wrapper for making template conversions simpler and easier to understand." alt="" coords="228,5,331,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_nodeset_a3ac3c4f4f11ffa9836496730f43fc56f_icgraph.png" border="0" usemap="#aclass_nodeset_a3ac3c4f4f11ffa9836496730f43fc56f_icgraph" alt=""/></div>
<map name="aclass_nodeset_a3ac3c4f4f11ffa9836496730f43fc56f_icgraph" id="aclass_nodeset_a3ac3c4f4f11ffa9836496730f43fc56f_icgraph">
<area shape="rect" title="Checks that all nodes in the nodeset for the specified attribute." alt="" coords="208,31,383,57"/>
<area shape="rect" href="class_location.html#a22fe41e44e3f9c730a0567e027d574b8" title="Function called once before any simulation cycles begin." alt="" coords="19,5,146,32"/>
<area shape="rect" href="class_social___media.html#aeffa774969faadf1c9046d4f3d5668b0" title="checks for Knowledge Trust Model (opitional), and Knowledge Parsing Model (required)." alt="" coords="5,56,160,83"/>
</map>
</div>

</div>
</div>
<a id="ac3410c8dc6dec8210e7d8fd83593cf12" name="ac3410c8dc6dec8210e7d8fd83593cf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3410c8dc6dec8210e7d8fd83593cf12">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nodeset::iterator Nodeset::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing the beyond the last node in the vector of nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the beyond the last node in the nodeset. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//nodeset has been preloaded with some agents; Mary, John, and Joe.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_nodeset.html">Nodeset</a>* agents = construct-&gt;get_NodesetManager()-&gt;get_nodeset(nodeset_names::agent);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;This nodeset conatins:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span>(Nodeset::iterator it = agents-&gt;begin(); it != agents-&gt;end(); ++it) {</div>
<div class="line">        std::cout &lt;&lt; it-&gt;name &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">This nodeset contains:
Mary
John
Joe
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes</p>
<p ><b>Exception Safety</b></p>
<p >No-throw guarantee: this member function never throws exceptions. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_nodeset_ac3410c8dc6dec8210e7d8fd83593cf12_icgraph.png" border="0" usemap="#aclass_nodeset_ac3410c8dc6dec8210e7d8fd83593cf12_icgraph" alt=""/></div>
<map name="aclass_nodeset_ac3410c8dc6dec8210e7d8fd83593cf12_icgraph" id="aclass_nodeset_ac3410c8dc6dec8210e7d8fd83593cf12_icgraph">
<area shape="rect" title="Returns an iterator pointing the beyond the last node in the vector of nodes." alt="" coords="180,5,279,32"/>
<area shape="rect" href="class_location.html#a22fe41e44e3f9c730a0567e027d574b8" title="Function called once before any simulation cycles begin." alt="" coords="5,5,132,32"/>
</map>
</div>

</div>
</div>
<a id="a7b35cb69f479d48c076330b54cbcad6e" name="a7b35cb69f479d48c076330b54cbcad6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b35cb69f479d48c076330b54cbcad6e">&#9670;&nbsp;</a></span>get_node_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_node.html">Node</a> * Nodeset::get_node_by_index </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a node using the node's index. </p>
<p >This function provides drastic speed up compared to <a class="el" href="class_nodeset.html#a8096d59927fe1e3fb7c803d1d87ac46e" title="Finds a node using the node&#39;s name.">get_node_by_name</a> as this function references a vector while the former references a binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The node's index in the nodeset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant pointer to the node with index matching the parameter <em>index</em>. Only constant functions of a class pointed to by a constant pointer can be called. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//nodeset has been preloaded with some agents; Mary, John, and Joe.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_nodeset.html">Nodeset</a>* agents = construct-&gt;get_NodesetManager()-&gt;get_nodeset(nodeset_names::agent);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_node.html">Node</a>* agent = agents-&gt;get_node_by_index(0);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Node at index 0 is &quot;</span> &lt;&lt; agent-&gt;<a class="code hl_variable" href="class_node.html#ab02f55471aa1234a61206317fa7f2ed3">name</a> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_node_html"><div class="ttname"><a href="class_node.html">Node</a></div><div class="ttdoc">Nodes are any type of entity with or without attributes.</div><div class="ttdef"><b>Definition:</b> NodesetManager.h:67</div></div>
<div class="ttc" id="aclass_node_html_ab02f55471aa1234a61206317fa7f2ed3"><div class="ttname"><a href="class_node.html#ab02f55471aa1234a61206317fa7f2ed3">Node::name</a></div><div class="ttdeci">const std::string name</div><div class="ttdoc">Name of the node</div><div class="ttdef"><b>Definition:</b> NodesetManager.h:91</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Node at index 0 is Mary </pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if index is out of bounds for the nodeset. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_nodeset_a7b35cb69f479d48c076330b54cbcad6e_icgraph.png" border="0" usemap="#aclass_nodeset_a7b35cb69f479d48c076330b54cbcad6e_icgraph" alt=""/></div>
<map name="aclass_nodeset_a7b35cb69f479d48c076330b54cbcad6e_icgraph" id="aclass_nodeset_a7b35cb69f479d48c076330b54cbcad6e_icgraph">
<area shape="rect" title="Finds a node using the node&#39;s index." alt="" coords="399,35,551,76"/>
<area shape="rect" href="class_social___media.html#a5103a5afefb1a218059f5118e3566e87" title="Appends the array of InteractionItems based on the submitted event and the intended receiver of the m..." alt="" coords="195,5,345,47"/>
<area shape="rect" href="class_knowledge_trust.html#a5030265aa9707a7b05eb14dd6d86b580" title="Add knowledge trust to knowledge items in messages if they do not already include them." alt="" coords="189,71,351,98"/>
<area shape="rect" href="class_social___media.html#a692bdc21cbf7165820290fdfcecd39ce" title="Agents read events in their feed and create messages based on the read events." alt="" coords="5,13,141,39"/>
</map>
</div>

</div>
</div>
<a id="a8096d59927fe1e3fb7c803d1d87ac46e" name="a8096d59927fe1e3fb7c803d1d87ac46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8096d59927fe1e3fb7c803d1d87ac46e">&#9670;&nbsp;</a></span>get_node_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_node.html">Node</a> * Nodeset::get_node_by_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a node using the node's name. </p>
<p >This function uses a binary tree to find a node, making its speed slower than <a class="el" href="class_nodeset.html#a7b35cb69f479d48c076330b54cbcad6e" title="Finds a node using the node&#39;s index.">get_node_by_index</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The node's name in the nodeset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant pointer to the node with name matching the parameter <em>name</em>. Only constant functions of a class pointed to by a constant pointer can be called. If a node with the matching name is not found, a null pointer is returned instead. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//nodeset has been preloaded with some agents; Mary, John, and Joe.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_nodeset.html">Nodeset</a>* agents = construct-&gt;get_NodesetManager()-&gt;get_nodeset(nodeset_names::agent);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_node.html">Node</a>* agent = agents-&gt;get_node_by_name(<span class="stringliteral">&quot;Mary&quot;</span>);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Node Mary is at index &quot;</span> &lt;&lt; agent-&gt;<a class="code hl_variable" href="class_node.html#a448247f87c0f03839c071595e08c745a">index</a> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_node_html_a448247f87c0f03839c071595e08c745a"><div class="ttname"><a href="class_node.html#a448247f87c0f03839c071595e08c745a">Node::index</a></div><div class="ttdeci">const unsigned int index</div><div class="ttdoc">Node index of the node</div><div class="ttdef"><b>Definition:</b> NodesetManager.h:94</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Node Mary is at index 0 </pre> <p ><b>Complexity</b></p>
<p >Logarithmic in size of nodeset. Underlying function uses <a href="https://www.cplusplus.com/reference/map/map/find/">map::find</a></p>
<p ><b>Iterator validity</b></p>
<p >No changes</p>
<p ><b>Exception Safety</b></p>
<p >No-throw guarantee: this member function never throws exceptions. If the node was not found, a null pointer is returned. </p>

</div>
</div>
<a id="a4fa078150cc61ae3ae9a8752c50639c7" name="a4fa078150cc61ae3ae9a8752c50639c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa078150cc61ae3ae9a8752c50639c7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Nodeset::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes in the nodeset </p>
<dl class="section return"><dt>Returns</dt><dd>A count of how many nodes are in the nodeset as an unsigned int. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//nodeset has been preloaded with some agents; Mary, John, and Joe.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_nodeset.html">Nodeset</a>* agents = construct-&gt;get_NodesetManager()-&gt;get_nodeset(nodeset_names::agent);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The number of nodes in this nodeset: &quot;</span> &lt;&lt; agents-&gt;size() &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">The number of nodes in this nodeset: 3 </pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes</p>
<p ><b>Exception Safety</b></p>
<p >No-throw guarantee: this member function never throws exceptions. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a59ee2255cdc2b09f495448e3f8bf307e" name="a59ee2255cdc2b09f495448e3f8bf307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ee2255cdc2b09f495448e3f8bf307e">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string Nodeset::name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_nodeset.html">Nodeset</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
