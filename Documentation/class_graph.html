<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Construct: Graph&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_dark.png"/></td>
  <td id="projectalign">
   <div id="projectname">Construct<span id="projectnumber">&#160;version 5.2.2</span>
   </div>
   <div id="projectbrief">An agent based modeling framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_graph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Data structure for storing graphs/networks.  
 <a href="class_graph.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Graph&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph__inherit__graph.png" border="0" usemap="#a_graph_3_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="a_graph_3_01_t_01_4_inherit__map" id="a_graph_3_01_t_01_4_inherit__map">
<area shape="rect" title="Data structure for storing graphs/networks." alt="" coords="18,80,106,107"/>
<area shape="rect" href="class_graph___interface.html" title="Parent class for Graph." alt="" coords="5,5,119,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Graph&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph__coll__graph.png" border="0" usemap="#a_graph_3_01_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="a_graph_3_01_t_01_4_coll__map" id="a_graph_3_01_t_01_4_coll__map">
<area shape="rect" title="Data structure for storing graphs/networks." alt="" coords="18,200,106,227"/>
<area shape="rect" href="class_graph___interface.html" title="Parent class for Graph." alt="" coords="5,124,119,151"/>
<area shape="rect" href="class_nodeset.html" title="A container for nodes." alt="" coords="27,5,97,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates over the start of each row.  <a href="class_graph_1_1col__begin__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator that iterates over the start of each column.  <a href="class_graph_1_1const__col__begin__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1const__full__col__iterator.html">const_full_col_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator that iterates over every row at a constant column.  <a href="class_graph_1_1const__full__col__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1const__full__row__iterator.html">const_full_row_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator that iterates over every column at a constant row.  <a href="class_graph_1_1const__full__row__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator that iterates over the start of each row.  <a href="class_graph_1_1const__row__begin__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1const__sparse__col__iterator.html">const_sparse_col_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator that iterates over each element whose value does not equal the skip value.  <a href="class_graph_1_1const__sparse__col__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1const__sparse__row__iterator.html">const_sparse_row_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator that iterates over each element whose value does not equal the skip value.  <a href="class_graph_1_1const__sparse__row__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1full__col__iterator.html">full_col_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates over every row at a constant column.  <a href="class_graph_1_1full__col__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates over every column at a constant row.  <a href="class_graph_1_1full__row__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates over the start of each row.  <a href="class_graph_1_1row__begin__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1sparse__col__iterator.html">sparse_col_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates over each element whose value does not equal the skip value.  <a href="class_graph_1_1sparse__col__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_1_1sparse__row__iterator.html">sparse_row_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates over each element whose value does not equal the skip value.  <a href="class_graph_1_1sparse__row__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae273f9fe0787d9140d32390db44513a0"><td class="memItemLeft" align="right" valign="top">virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a> (unsigned int row, unsigned int col)</td></tr>
<tr class="memdesc:ae273f9fe0787d9140d32390db44513a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the specified link value.  <a href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">More...</a><br /></td></tr>
<tr class="separator:ae273f9fe0787d9140d32390db44513a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f20d992e0af999c8aea5bbd634a8ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a03f20d992e0af999c8aea5bbd634a8ba">at</a> (unsigned int row, unsigned int col, const T &amp;data)</td></tr>
<tr class="memdesc:a03f20d992e0af999c8aea5bbd634a8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a values and either sets the entry to that value or removes the entry if the submitted value is equal to the default value.  <a href="class_graph.html#a03f20d992e0af999c8aea5bbd634a8ba">More...</a><br /></td></tr>
<tr class="separator:a03f20d992e0af999c8aea5bbd634a8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb687de64b37c4454395f226e65af57e"><td class="memItemLeft" align="right" valign="top">virtual const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aeb687de64b37c4454395f226e65af57e">examine</a> (unsigned int row, unsigned int col) const</td></tr>
<tr class="memdesc:aeb687de64b37c4454395f226e65af57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a constant reference to the specified element.  <a href="class_graph.html#aeb687de64b37c4454395f226e65af57e">More...</a><br /></td></tr>
<tr class="separator:aeb687de64b37c4454395f226e65af57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2276dcbd31bcebf8152eee2cdfa2c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4b2276dcbd31bcebf8152eee2cdfa2c8">clear</a> (const T &amp;data)</td></tr>
<tr class="memdesc:a4b2276dcbd31bcebf8152eee2cdfa2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all elements equal to the submitted value.  <a href="class_graph.html#a4b2276dcbd31bcebf8152eee2cdfa2c8">More...</a><br /></td></tr>
<tr class="separator:a4b2276dcbd31bcebf8152eee2cdfa2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6e316fc6741c9a45328c4026013e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8e6e316fc6741c9a45328c4026013e44">add_delta</a> (unsigned int row, unsigned int col, const T &amp;data)</td></tr>
<tr class="memdesc:a8e6e316fc6741c9a45328c4026013e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a queued modification to the specified element.  <a href="class_graph.html#a8e6e316fc6741c9a45328c4026013e44">More...</a><br /></td></tr>
<tr class="separator:a8e6e316fc6741c9a45328c4026013e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddc3bdced41c8dcb5b93733dcb43d8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adddc3bdced41c8dcb5b93733dcb43d8a">push_deltas</a> (void)</td></tr>
<tr class="memdesc:adddc3bdced41c8dcb5b93733dcb43d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies all queued modifications created by the <a class="el" href="class_graph.html#a8e6e316fc6741c9a45328c4026013e44">add_delta</a> function.  <a href="class_graph.html#adddc3bdced41c8dcb5b93733dcb43d8a">More...</a><br /></td></tr>
<tr class="separator:adddc3bdced41c8dcb5b93733dcb43d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd874823e88cda2367254f53f20f989"><td class="memItemLeft" align="right" valign="top">virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aafd874823e88cda2367254f53f20f989">at</a> (<a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:aafd874823e88cda2367254f53f20f989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to link value the iterator points to.  <a href="class_graph.html#aafd874823e88cda2367254f53f20f989">More...</a><br /></td></tr>
<tr class="separator:aafd874823e88cda2367254f53f20f989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af704568b1bd53e5d6a4090c8bb85f542"><td class="memItemLeft" align="right" valign="top"><a id="af704568b1bd53e5d6a4090c8bb85f542" name="af704568b1bd53e5d6a4090c8bb85f542"></a>
virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (<a class="el" href="class_graph_1_1sparse__row__iterator.html">sparse_row_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:af704568b1bd53e5d6a4090c8bb85f542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to link value the iterator points to. See <a class="el" href="class_graph.html#aafd874823e88cda2367254f53f20f989" title="Gets a reference to link value the iterator points to.">Graph::at(full_row_iterator&amp; it)</a>. <br /></td></tr>
<tr class="separator:af704568b1bd53e5d6a4090c8bb85f542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74af4c196125106389778a7d3a00b183"><td class="memItemLeft" align="right" valign="top"><a id="a74af4c196125106389778a7d3a00b183" name="a74af4c196125106389778a7d3a00b183"></a>
virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (<a class="el" href="class_graph_1_1full__col__iterator.html">full_col_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a74af4c196125106389778a7d3a00b183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to link value the iterator points to. See <a class="el" href="class_graph.html#aafd874823e88cda2367254f53f20f989" title="Gets a reference to link value the iterator points to.">Graph::at(full_row_iterator&amp; it)</a>. <br /></td></tr>
<tr class="separator:a74af4c196125106389778a7d3a00b183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a671f2d73f3e4ce22a286129b77bed"><td class="memItemLeft" align="right" valign="top"><a id="a43a671f2d73f3e4ce22a286129b77bed" name="a43a671f2d73f3e4ce22a286129b77bed"></a>
virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (<a class="el" href="class_graph_1_1sparse__col__iterator.html">sparse_col_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a43a671f2d73f3e4ce22a286129b77bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to link value the iterator points to. See <a class="el" href="class_graph.html#aafd874823e88cda2367254f53f20f989" title="Gets a reference to link value the iterator points to.">Graph::at(full_row_iterator&amp; it)</a>. <br /></td></tr>
<tr class="separator:a43a671f2d73f3e4ce22a286129b77bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea192ad83b79ba495919afebbadf133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2ea192ad83b79ba495919afebbadf133">at</a> (<a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a> &amp;it, const T &amp;data)</td></tr>
<tr class="memdesc:a2ea192ad83b79ba495919afebbadf133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a values and either sets the entry to that value or removes the entry if the submitted value is equal to the default value.  <a href="class_graph.html#a2ea192ad83b79ba495919afebbadf133">More...</a><br /></td></tr>
<tr class="separator:a2ea192ad83b79ba495919afebbadf133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d6d60417755a0039c23330b6abd7a2"><td class="memItemLeft" align="right" valign="top"><a id="a11d6d60417755a0039c23330b6abd7a2" name="a11d6d60417755a0039c23330b6abd7a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (<a class="el" href="class_graph_1_1sparse__row__iterator.html">sparse_row_iterator</a> &amp;it, const T &amp;data)</td></tr>
<tr class="memdesc:a11d6d60417755a0039c23330b6abd7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_graph.html#a2ea192ad83b79ba495919afebbadf133" title="Takes a values and either sets the entry to that value or removes the entry if the submitted value is...">Graph::at(full_row_iterator&amp;, const T&amp;)</a> <br /></td></tr>
<tr class="separator:a11d6d60417755a0039c23330b6abd7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988755fd2a8ade09629ba6c65942e50e"><td class="memItemLeft" align="right" valign="top"><a id="a988755fd2a8ade09629ba6c65942e50e" name="a988755fd2a8ade09629ba6c65942e50e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (<a class="el" href="class_graph_1_1full__col__iterator.html">full_col_iterator</a> &amp;it, const T &amp;data)</td></tr>
<tr class="memdesc:a988755fd2a8ade09629ba6c65942e50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_graph.html#a2ea192ad83b79ba495919afebbadf133" title="Takes a values and either sets the entry to that value or removes the entry if the submitted value is...">Graph::at(full_row_iterator&amp;, const T&amp;)</a> <br /></td></tr>
<tr class="separator:a988755fd2a8ade09629ba6c65942e50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7597eaf7bbf4659ca443c067254f4a"><td class="memItemLeft" align="right" valign="top"><a id="aea7597eaf7bbf4659ca443c067254f4a" name="aea7597eaf7bbf4659ca443c067254f4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (<a class="el" href="class_graph_1_1sparse__col__iterator.html">sparse_col_iterator</a> &amp;it, const T &amp;data)</td></tr>
<tr class="memdesc:aea7597eaf7bbf4659ca443c067254f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_graph.html#a2ea192ad83b79ba495919afebbadf133" title="Takes a values and either sets the entry to that value or removes the entry if the submitted value is...">Graph::at(full_row_iterator&amp;, const T&amp;)</a> <br /></td></tr>
<tr class="separator:aea7597eaf7bbf4659ca443c067254f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f4c0d626d78ca05cce2e644cb4a59"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a> (unsigned int row_index)</td></tr>
<tr class="memdesc:ab80f4c0d626d78ca05cce2e644cb4a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a> pointing to beginning of the specified row  <a href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">More...</a><br /></td></tr>
<tr class="separator:ab80f4c0d626d78ca05cce2e644cb4a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546de7e197b5a6fae846d03de1fa1efb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1const__full__row__iterator.html">const_full_row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a546de7e197b5a6fae846d03de1fa1efb">full_row_begin</a> (unsigned int row_index) const</td></tr>
<tr class="memdesc:a546de7e197b5a6fae846d03de1fa1efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1const__full__row__iterator.html">const_full_row_iterator</a> pointing to beginning of the specified row  <a href="class_graph.html#a546de7e197b5a6fae846d03de1fa1efb">More...</a><br /></td></tr>
<tr class="separator:a546de7e197b5a6fae846d03de1fa1efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae490e3382c80b109d6ff6d4ea94ea43"><td class="memItemLeft" align="right" valign="top"><a id="aae490e3382c80b109d6ff6d4ea94ea43" name="aae490e3382c80b109d6ff6d4ea94ea43"></a>
virtual <a class="el" href="class_graph_1_1const__full__row__iterator.html">const_full_row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>full_row_cbegin</b> (unsigned int row_index) const</td></tr>
<tr class="memdesc:aae490e3382c80b109d6ff6d4ea94ea43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function is identical to the const <a class="el" href="class_graph.html#a546de7e197b5a6fae846d03de1fa1efb">full_row_begin </a>. <br /></td></tr>
<tr class="separator:aae490e3382c80b109d6ff6d4ea94ea43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45c25683e8539f61314e848dd45c8ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1sparse__row__iterator.html">sparse_row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac45c25683e8539f61314e848dd45c8ed">sparse_row_begin</a> (unsigned int row_index, const T &amp;skip_data)</td></tr>
<tr class="memdesc:ac45c25683e8539f61314e848dd45c8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1sparse__row__iterator.html" title="An iterator that iterates over each element whose value does not equal the skip value.">Graph::sparse_row_iterator</a> pointing to beginning of the specified row  <a href="class_graph.html#ac45c25683e8539f61314e848dd45c8ed">More...</a><br /></td></tr>
<tr class="separator:ac45c25683e8539f61314e848dd45c8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dae102a7b8b502c8f1dffeecfbf107"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1const__sparse__row__iterator.html">const_sparse_row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a22dae102a7b8b502c8f1dffeecfbf107">sparse_row_begin</a> (unsigned int row_index, const T &amp;skip_data) const</td></tr>
<tr class="memdesc:a22dae102a7b8b502c8f1dffeecfbf107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1const__sparse__row__iterator.html" title="A constant iterator that iterates over each element whose value does not equal the skip value.">Graph::const_sparse_row_iterator</a> pointing to beginning of the specified row.  <a href="class_graph.html#a22dae102a7b8b502c8f1dffeecfbf107">More...</a><br /></td></tr>
<tr class="separator:a22dae102a7b8b502c8f1dffeecfbf107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cafa237f6b8afa2084b66ce6dd7d337"><td class="memItemLeft" align="right" valign="top"><a id="a5cafa237f6b8afa2084b66ce6dd7d337" name="a5cafa237f6b8afa2084b66ce6dd7d337"></a>
virtual <a class="el" href="class_graph_1_1const__sparse__row__iterator.html">const_sparse_row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_row_cbegin</b> (unsigned int row_index, const T &amp;skip_data) const</td></tr>
<tr class="memdesc:a5cafa237f6b8afa2084b66ce6dd7d337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function is identical to the const <a class="el" href="">sparse_row_begin </a>. <br /></td></tr>
<tr class="separator:a5cafa237f6b8afa2084b66ce6dd7d337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae45c3cac1d7581052b2ab3a2306772"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aeae45c3cac1d7581052b2ab3a2306772">begin_rows</a> (void)</td></tr>
<tr class="memdesc:aeae45c3cac1d7581052b2ab3a2306772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a> pointing to the first row in the data structure.  <a href="class_graph.html#aeae45c3cac1d7581052b2ab3a2306772">More...</a><br /></td></tr>
<tr class="separator:aeae45c3cac1d7581052b2ab3a2306772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ad484e474eda1bf856a3b74e258e45"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac6ad484e474eda1bf856a3b74e258e45">begin_rows</a> (void) const</td></tr>
<tr class="memdesc:ac6ad484e474eda1bf856a3b74e258e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a> pointing to the first row in the data structure.  <a href="class_graph.html#ac6ad484e474eda1bf856a3b74e258e45">More...</a><br /></td></tr>
<tr class="separator:ac6ad484e474eda1bf856a3b74e258e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c67dd36adb393616a9ab2504db38ead"><td class="memItemLeft" align="right" valign="top"><a id="a2c67dd36adb393616a9ab2504db38ead" name="a2c67dd36adb393616a9ab2504db38ead"></a>
virtual <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_rows</b> (void) const</td></tr>
<tr class="memdesc:a2c67dd36adb393616a9ab2504db38ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function is identical to the const <a class="el" href="class_graph.html#ac6ad484e474eda1bf856a3b74e258e45">begin_rows </a>. <br /></td></tr>
<tr class="separator:a2c67dd36adb393616a9ab2504db38ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abce6c3ff7af131ff433c71646d17a7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3abce6c3ff7af131ff433c71646d17a7">begin_rows</a> (unsigned int row_index)</td></tr>
<tr class="memdesc:a3abce6c3ff7af131ff433c71646d17a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a> pointing to the specified row in the data structure.  <a href="class_graph.html#a3abce6c3ff7af131ff433c71646d17a7">More...</a><br /></td></tr>
<tr class="separator:a3abce6c3ff7af131ff433c71646d17a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9680b901c7756db81bf8bea27c6a89d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af9680b901c7756db81bf8bea27c6a89d">begin_rows</a> (unsigned int row_index) const</td></tr>
<tr class="separator:af9680b901c7756db81bf8bea27c6a89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1099c46d95a7ffbfa8669eba70270e5"><td class="memItemLeft" align="right" valign="top"><a id="ae1099c46d95a7ffbfa8669eba70270e5" name="ae1099c46d95a7ffbfa8669eba70270e5"></a>
virtual <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_rows</b> (unsigned int row_index) const</td></tr>
<tr class="memdesc:ae1099c46d95a7ffbfa8669eba70270e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function is identical to the const <a class="el" href="class_graph.html#af9680b901c7756db81bf8bea27c6a89d">begin_rows </a>. <br /></td></tr>
<tr class="separator:ae1099c46d95a7ffbfa8669eba70270e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25ece15d9f34295d20774d48694461b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_graph__iterator.html">Graph_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af25ece15d9f34295d20774d48694461b">row_end</a> (unsigned int row_index) const</td></tr>
<tr class="memdesc:af25ece15d9f34295d20774d48694461b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the end of the specified row.  <a href="class_graph.html#af25ece15d9f34295d20774d48694461b">More...</a><br /></td></tr>
<tr class="separator:af25ece15d9f34295d20774d48694461b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b95cf23e3b86d06f23a9d16c9987e3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_graph__iterator.html">Graph_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a74b95cf23e3b86d06f23a9d16c9987e3">end_rows</a> (void) const</td></tr>
<tr class="memdesc:a74b95cf23e3b86d06f23a9d16c9987e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the beginning of the after the last row.  <a href="class_graph.html#a74b95cf23e3b86d06f23a9d16c9987e3">More...</a><br /></td></tr>
<tr class="separator:a74b95cf23e3b86d06f23a9d16c9987e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abbd42d0e097f3c67df57fe2646fc57"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1full__col__iterator.html">full_col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3abbd42d0e097f3c67df57fe2646fc57">full_col_begin</a> (unsigned int col_index)</td></tr>
<tr class="memdesc:a3abbd42d0e097f3c67df57fe2646fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1full__col__iterator.html">full_col_iterator</a> pointing to beginning of the specified column  <a href="class_graph.html#a3abbd42d0e097f3c67df57fe2646fc57">More...</a><br /></td></tr>
<tr class="separator:a3abbd42d0e097f3c67df57fe2646fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819f95b807fc0ef9c13ab40eaf08f737"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1const__full__col__iterator.html">const_full_col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a819f95b807fc0ef9c13ab40eaf08f737">full_col_begin</a> (unsigned int col_index) const</td></tr>
<tr class="memdesc:a819f95b807fc0ef9c13ab40eaf08f737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1const__full__col__iterator.html">const_full_col_iterator</a> pointing to beginning of the specified column  <a href="class_graph.html#a819f95b807fc0ef9c13ab40eaf08f737">More...</a><br /></td></tr>
<tr class="separator:a819f95b807fc0ef9c13ab40eaf08f737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e784c57c02881dbf2225897074a2d7b"><td class="memItemLeft" align="right" valign="top"><a id="a0e784c57c02881dbf2225897074a2d7b" name="a0e784c57c02881dbf2225897074a2d7b"></a>
virtual <a class="el" href="class_graph_1_1const__full__col__iterator.html">const_full_col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>full_col_cbegin</b> (unsigned int col_index) const</td></tr>
<tr class="memdesc:a0e784c57c02881dbf2225897074a2d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function is identical to the const <a class="el" href="class_graph.html#a819f95b807fc0ef9c13ab40eaf08f737">full_col_begin </a>. <br /></td></tr>
<tr class="separator:a0e784c57c02881dbf2225897074a2d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4dd648ff233ba66033809b251394c4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1sparse__col__iterator.html">sparse_col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3d4dd648ff233ba66033809b251394c4">sparse_col_begin</a> (unsigned int col_index, const T &amp;skip_data)</td></tr>
<tr class="memdesc:a3d4dd648ff233ba66033809b251394c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1sparse__col__iterator.html" title="An iterator that iterates over each element whose value does not equal the skip value.">Graph::sparse_col_iterator</a> pointing to beginning of the specified column  <a href="class_graph.html#a3d4dd648ff233ba66033809b251394c4">More...</a><br /></td></tr>
<tr class="separator:a3d4dd648ff233ba66033809b251394c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cd3e90f853b76773711ec80f341643"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1const__sparse__col__iterator.html">const_sparse_col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac2cd3e90f853b76773711ec80f341643">sparse_col_begin</a> (unsigned int col_index, const T &amp;skip_data) const</td></tr>
<tr class="memdesc:ac2cd3e90f853b76773711ec80f341643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1const__sparse__col__iterator.html" title="A constant iterator that iterates over each element whose value does not equal the skip value.">Graph::const_sparse_col_iterator</a> pointing to beginning of the specified column.  <a href="class_graph.html#ac2cd3e90f853b76773711ec80f341643">More...</a><br /></td></tr>
<tr class="separator:ac2cd3e90f853b76773711ec80f341643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3928ed723ca3f18d4be93e8279d9ecfa"><td class="memItemLeft" align="right" valign="top"><a id="a3928ed723ca3f18d4be93e8279d9ecfa" name="a3928ed723ca3f18d4be93e8279d9ecfa"></a>
virtual <a class="el" href="class_graph_1_1const__sparse__col__iterator.html">const_sparse_col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_col_cbegin</b> (unsigned int col_index, const T &amp;skip_data) const</td></tr>
<tr class="memdesc:a3928ed723ca3f18d4be93e8279d9ecfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function is identical to the const <a class="el" href="">sparse_col_begin </a>. <br /></td></tr>
<tr class="separator:a3928ed723ca3f18d4be93e8279d9ecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5822222bd7e2c2c5235ec95240f415bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5822222bd7e2c2c5235ec95240f415bb">begin_cols</a> (void)</td></tr>
<tr class="memdesc:a5822222bd7e2c2c5235ec95240f415bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a> pointing to the first column in the data structure.  <a href="class_graph.html#a5822222bd7e2c2c5235ec95240f415bb">More...</a><br /></td></tr>
<tr class="separator:a5822222bd7e2c2c5235ec95240f415bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8490eb739e0822e3f4a2787012d4ef0b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8490eb739e0822e3f4a2787012d4ef0b">begin_cols</a> (void) const</td></tr>
<tr class="memdesc:a8490eb739e0822e3f4a2787012d4ef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a> pointing to the first column in the data structure.  <a href="class_graph.html#a8490eb739e0822e3f4a2787012d4ef0b">More...</a><br /></td></tr>
<tr class="separator:a8490eb739e0822e3f4a2787012d4ef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5308ad2fc5755b98823c27bab1863652"><td class="memItemLeft" align="right" valign="top"><a id="a5308ad2fc5755b98823c27bab1863652" name="a5308ad2fc5755b98823c27bab1863652"></a>
virtual <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_cols</b> (void) const</td></tr>
<tr class="memdesc:a5308ad2fc5755b98823c27bab1863652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function is identical to the const <a class="el" href="class_graph.html#a8490eb739e0822e3f4a2787012d4ef0b">begin_cols </a>. <br /></td></tr>
<tr class="separator:a5308ad2fc5755b98823c27bab1863652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffc5fc35bab3a020e5e13eb6948184e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a6ffc5fc35bab3a020e5e13eb6948184e">begin_cols</a> (unsigned int col_index)</td></tr>
<tr class="memdesc:a6ffc5fc35bab3a020e5e13eb6948184e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a> pointing to the specified column in the data structure.  <a href="class_graph.html#a6ffc5fc35bab3a020e5e13eb6948184e">More...</a><br /></td></tr>
<tr class="separator:a6ffc5fc35bab3a020e5e13eb6948184e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f5136e81b4c64fcf8722ab8084a47d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a67f5136e81b4c64fcf8722ab8084a47d">begin_cols</a> (unsigned int col_index) const</td></tr>
<tr class="memdesc:a67f5136e81b4c64fcf8722ab8084a47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a> pointing to the specified column in the data structure.  <a href="class_graph.html#a67f5136e81b4c64fcf8722ab8084a47d">More...</a><br /></td></tr>
<tr class="separator:a67f5136e81b4c64fcf8722ab8084a47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06499a2c6b4c1e27c3f47a87dbf0dd36"><td class="memItemLeft" align="right" valign="top"><a id="a06499a2c6b4c1e27c3f47a87dbf0dd36" name="a06499a2c6b4c1e27c3f47a87dbf0dd36"></a>
virtual <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_cols</b> (unsigned int col_index) const</td></tr>
<tr class="memdesc:a06499a2c6b4c1e27c3f47a87dbf0dd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function is identical to the const <a class="el" href="class_graph.html#a67f5136e81b4c64fcf8722ab8084a47d">begin_cols </a>. <br /></td></tr>
<tr class="separator:a06499a2c6b4c1e27c3f47a87dbf0dd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5985b4292f2ac31e8cbc5b0cf74f0235"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_graph__iterator.html">Graph_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5985b4292f2ac31e8cbc5b0cf74f0235">col_end</a> (unsigned int col_index) const</td></tr>
<tr class="memdesc:a5985b4292f2ac31e8cbc5b0cf74f0235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the end of the specified column.  <a href="class_graph.html#a5985b4292f2ac31e8cbc5b0cf74f0235">More...</a><br /></td></tr>
<tr class="separator:a5985b4292f2ac31e8cbc5b0cf74f0235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c67a1c544522468a7c47b14606d805"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_graph__iterator.html">Graph_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad8c67a1c544522468a7c47b14606d805">end_cols</a> (void) const</td></tr>
<tr class="memdesc:ad8c67a1c544522468a7c47b14606d805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the beginning of the after the last column.  <a href="class_graph.html#ad8c67a1c544522468a7c47b14606d805">More...</a><br /></td></tr>
<tr class="separator:ad8c67a1c544522468a7c47b14606d805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87724335d73eb3e1960f76ad4cd6a822"><td class="memItemLeft" align="right" valign="top"><a id="a87724335d73eb3e1960f76ad4cd6a822" name="a87724335d73eb3e1960f76ad4cd6a822"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>push_deltas</b> (void)</td></tr>
<tr class="memdesc:a87724335d73eb3e1960f76ad4cd6a822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that allows the deltas in a <a class="el" href="class_graph.html" title="Data structure for storing graphs/networks.">Graph</a> to be pushed without needing to convert the <a class="el" href="class_graph___interface.html" title="Parent class for Graph.">Graph_Interface</a> into its child type. <br /></td></tr>
<tr class="separator:a87724335d73eb3e1960f76ad4cd6a822"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a132ade33dcc4de9745e9333a205706d1"><td class="memItemLeft" align="right" valign="top"><a id="a132ade33dcc4de9745e9333a205706d1" name="a132ade33dcc4de9745e9333a205706d1"></a>
const T&#160;</td><td class="memItemRight" valign="bottom"><b>def_val</b></td></tr>
<tr class="memdesc:a132ade33dcc4de9745e9333a205706d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default value a entry will have if that entry is not stored in memory. <br /></td></tr>
<tr class="separator:a132ade33dcc4de9745e9333a205706d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7869680f5e99dffec4183c26b667a8"><td class="memItemLeft" align="right" valign="top"><a id="a1f7869680f5e99dffec4183c26b667a8" name="a1f7869680f5e99dffec4183c26b667a8"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>col_dense</b></td></tr>
<tr class="memdesc:a1f7869680f5e99dffec4183c26b667a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the column representation is dense, false if the representation is sparse. <br /></td></tr>
<tr class="separator:a1f7869680f5e99dffec4183c26b667a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f68d64ee2af9f83ebf4651fb073051"><td class="memItemLeft" align="right" valign="top"><a id="a04f68d64ee2af9f83ebf4651fb073051" name="a04f68d64ee2af9f83ebf4651fb073051"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>row_dense</b></td></tr>
<tr class="memdesc:a04f68d64ee2af9f83ebf4651fb073051"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the row representation is dense, false if the representation is sparse. <br /></td></tr>
<tr class="separator:a04f68d64ee2af9f83ebf4651fb073051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_class_graph___interface"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_graph___interface')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_graph___interface.html">Graph_Interface</a></td></tr>
<tr class="memitem:aca3626d38cba79a0248bbd46fa28c262 inherit pub_attribs_class_graph___interface"><td class="memItemLeft" align="right" valign="top"><a id="aca3626d38cba79a0248bbd46fa28c262" name="aca3626d38cba79a0248bbd46fa28c262"></a>
const <a class="el" href="class_nodeset.html">Nodeset</a> *const&#160;</td><td class="memItemRight" valign="bottom"><b>source_nodeset</b></td></tr>
<tr class="memdesc:aca3626d38cba79a0248bbd46fa28c262 inherit pub_attribs_class_graph___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodeset in which each node corresponds to a row in the data structure. <br /></td></tr>
<tr class="separator:aca3626d38cba79a0248bbd46fa28c262 inherit pub_attribs_class_graph___interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6dcc096e10b4d260b975740b240f9b inherit pub_attribs_class_graph___interface"><td class="memItemLeft" align="right" valign="top"><a id="a8e6dcc096e10b4d260b975740b240f9b" name="a8e6dcc096e10b4d260b975740b240f9b"></a>
const <a class="el" href="class_nodeset.html">Nodeset</a> *const&#160;</td><td class="memItemRight" valign="bottom"><b>target_nodeset</b></td></tr>
<tr class="memdesc:a8e6dcc096e10b4d260b975740b240f9b inherit pub_attribs_class_graph___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodeset in which each node corresponds to a column in the data structure. <br /></td></tr>
<tr class="separator:a8e6dcc096e10b4d260b975740b240f9b inherit pub_attribs_class_graph___interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44dd6525a995e62d5dc8f0fe4552a79 inherit pub_attribs_class_graph___interface"><td class="memItemLeft" align="right" valign="top"><a id="aa44dd6525a995e62d5dc8f0fe4552a79" name="aa44dd6525a995e62d5dc8f0fe4552a79"></a>
const <a class="el" href="class_nodeset.html">Nodeset</a> *const&#160;</td><td class="memItemRight" valign="bottom"><b>slice_nodeset</b></td></tr>
<tr class="memdesc:aa44dd6525a995e62d5dc8f0fe4552a79 inherit pub_attribs_class_graph___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodeset in which each node corresponds to a slice in the data structure. <br /></td></tr>
<tr class="separator:aa44dd6525a995e62d5dc8f0fe4552a79 inherit pub_attribs_class_graph___interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577e8fae2d425ea0743de705307a09e8 inherit pub_attribs_class_graph___interface"><td class="memItemLeft" align="right" valign="top"><a id="a577e8fae2d425ea0743de705307a09e8" name="a577e8fae2d425ea0743de705307a09e8"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="memdesc:a577e8fae2d425ea0743de705307a09e8 inherit pub_attribs_class_graph___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the network. <br /></td></tr>
<tr class="separator:a577e8fae2d425ea0743de705307a09e8 inherit pub_attribs_class_graph___interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2802a1f75dbe4a19e3959752f25fc9 inherit pub_attribs_class_graph___interface"><td class="memItemLeft" align="right" valign="top"><a id="aec2802a1f75dbe4a19e3959752f25fc9" name="aec2802a1f75dbe4a19e3959752f25fc9"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>edge_type</b></td></tr>
<tr class="memdesc:aec2802a1f75dbe4a19e3959752f25fc9 inherit pub_attribs_class_graph___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the edge's data type. Set by <a class="el" href="namespacedynet.html#adaa7ac02f54cb6c53d1d9874c5b97096" title="Returns a string based on the submitted type.">dynet::get_type_name</a>. <br /></td></tr>
<tr class="separator:aec2802a1f75dbe4a19e3959752f25fc9 inherit pub_attribs_class_graph___interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8fb36cc7c750c01fbe7b5e60283d7e inherit pub_attribs_class_graph___interface"><td class="memItemLeft" align="right" valign="top"><a id="a5e8fb36cc7c750c01fbe7b5e60283d7e" name="a5e8fb36cc7c750c01fbe7b5e60283d7e"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>row_size</b></td></tr>
<tr class="memdesc:a5e8fb36cc7c750c01fbe7b5e60283d7e inherit pub_attribs_class_graph___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of rows in the data structure. Equalivilent to the size of the source nodeset. <br /></td></tr>
<tr class="separator:a5e8fb36cc7c750c01fbe7b5e60283d7e inherit pub_attribs_class_graph___interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d482f27f81154f9bb3e1391e1270950 inherit pub_attribs_class_graph___interface"><td class="memItemLeft" align="right" valign="top"><a id="a1d482f27f81154f9bb3e1391e1270950" name="a1d482f27f81154f9bb3e1391e1270950"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>col_size</b></td></tr>
<tr class="memdesc:a1d482f27f81154f9bb3e1391e1270950 inherit pub_attribs_class_graph___interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns in the data structure. Equalivilent to the size of the target nodeset. <br /></td></tr>
<tr class="separator:a1d482f27f81154f9bb3e1391e1270950 inherit pub_attribs_class_graph___interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class Graph&lt; T &gt;</div><p >Data structure for storing graphs/networks. </p>
<p >Graphs/networks connect one node to another node using links/edges. In the case of 3d graphs, these edges can themselves be another dimension. Three dimensions are currently supported; source, target, and slice, with the last being used exclusively in 3d graphs. Edge types currently supported are bool, int, unsigned int, float, and string.</p>
<p >The source and target dimensions can be sparse or dense. This class has been constructed such that the source and target densities do not impact behaviour, only cpu and memory usage. From a developer's point of view, it is best to assume both dimensions are sparse as there is no complexity penalty if the dimensions are dense. The slice dimension density must match that requested by a model. When using a 3d graph with a slice dimension, a data type of vector&lt;T&gt; or map&lt;unsigned int, T&gt; is used for dense or sparse representation, respectively. The edge_type identifier in the parent class <a class="el" href="class_graph___interface.html" title="Parent class for Graph.">Graph_Interface</a> both indicates slice dimension density, and the data type used. By checking edge_type, conversion from 2d to 3d graphs is avoided as is conversion between two different data types such as float and string. The string used to define edge_type can be found using the function <a class="el" href="namespacedynet.html#adaa7ac02f54cb6c53d1d9874c5b97096">dynet::get_type_name</a>.</p>
<p >The <a class="el" href="class_graph.html" title="Data structure for storing graphs/networks.">Graph</a> structure itself is a collection of entries, which are not synonymous with links. When a link is examined using a soft examine, the entry's value is returned if the entry exists, otherwise the default value is returned. In a hard examine, an entry is allocated and the default value copied into it before returning the entry's value. Thus there can exist many links, with no entries with the correct default value. In a dense representation, every possible entry is allocated and default value is copied into each entry. In a sparse representation, entries are only allocated during a hard examine. Setting an entry with a hard examine to equal the default value is not recommended. While in a dense representation there is no consequence, excessive cpu and memory usage is wasted allocating a new entry.</p>
<p >Graphs can only be constructed or deconstructed by the <a class="el" href="class_graph_manager.html" title="Manages all graphs in Construct.">GraphManager</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e6e316fc6741c9a45328c4026013e44" name="a8e6e316fc6741c9a45328c4026013e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6e316fc6741c9a45328c4026013e44">&#9670;&nbsp;</a></span>add_delta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::add_delta </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a queued modification to the specified element. </p>
<p >The queued modification is not applied until <a class="el" href="class_graph.html#adddc3bdced41c8dcb5b93733dcb43d8a">push_deltas</a> is called. At that time, the element is replaced with the specified data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row index of the desired element. </td></tr>
    <tr><td class="paramname">col</td><td>Column index of the desired element. </td></tr>
    <tr><td class="paramname">data</td><td>Column index of the desired element. </td></tr>
  </table>
  </dd>
</dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#a8e6e316fc6741c9a45328c4026013e44">add_delta</a>(0, 0, 1);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 0 before pushing deltas:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(0); it != mygraph-&gt;<a class="code hl_function" href="class_graph.html#af25ece15d9f34295d20774d48694461b">row_end</a>(0); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#adddc3bdced41c8dcb5b93733dcb43d8a">push_deltas</a>();</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 0 after pushing deltas:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(0); it != mygraph-&gt;<a class="code hl_function" href="class_graph.html#af25ece15d9f34295d20774d48694461b">row_end</a>(0); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_1_1full__row__iterator_html"><div class="ttname"><a href="class_graph_1_1full__row__iterator.html">Graph::full_row_iterator</a></div><div class="ttdoc">An iterator that iterates over every column at a constant row.</div><div class="ttdef"><b>Definition:</b> Graph.h:352</div></div>
<div class="ttc" id="aclass_graph_html"><div class="ttname"><a href="class_graph.html">Graph</a></div><div class="ttdoc">Data structure for storing graphs/networks.</div><div class="ttdef"><b>Definition:</b> Graph.h:204</div></div>
<div class="ttc" id="aclass_graph_html_a8e6e316fc6741c9a45328c4026013e44"><div class="ttname"><a href="class_graph.html#a8e6e316fc6741c9a45328c4026013e44">Graph::add_delta</a></div><div class="ttdeci">void add_delta(unsigned int row, unsigned int col, const T &amp;data)</div><div class="ttdoc">Adds a queued modification to the specified element.</div><div class="ttdef"><b>Definition:</b> Graph.cpp:99</div></div>
<div class="ttc" id="aclass_graph_html_ab80f4c0d626d78ca05cce2e644cb4a59"><div class="ttname"><a href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">Graph::full_row_begin</a></div><div class="ttdeci">virtual full_row_iterator full_row_begin(unsigned int row_index)</div><div class="ttdoc">Returns a full_row_iterator pointing to beginning of the specified row</div><div class="ttdef"><b>Definition:</b> Graph.h:1450</div></div>
<div class="ttc" id="aclass_graph_html_adddc3bdced41c8dcb5b93733dcb43d8a"><div class="ttname"><a href="class_graph.html#adddc3bdced41c8dcb5b93733dcb43d8a">Graph::push_deltas</a></div><div class="ttdeci">void push_deltas(void)</div><div class="ttdoc">Applies all queued modifications created by the add_delta function.</div><div class="ttdef"><b>Definition:</b> Graph.cpp:108</div></div>
<div class="ttc" id="aclass_graph_html_af25ece15d9f34295d20774d48694461b"><div class="ttname"><a href="class_graph.html#af25ece15d9f34295d20774d48694461b">Graph::row_end</a></div><div class="ttdeci">const Graph_iterator row_end(unsigned int row_index) const</div><div class="ttdoc">Returns a Graph_iterator pointing to the end of the specified row.</div><div class="ttdef"><b>Definition:</b> Graph.cpp:121</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 0 before pushing deltas: 0 1 4 2 </pre> <pre class="fragment">row 0 after pushing deltas: 1 1 4 2 </pre> <p ><b>Complexity</b></p>
<p >Constant.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if either row or col is out of bounds of the source and target nodeset, respectively. <br  />
 </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_a8e6e316fc6741c9a45328c4026013e44_icgraph.png" border="0" usemap="#aclass_graph_a8e6e316fc6741c9a45328c4026013e44_icgraph" alt=""/></div>
<map name="aclass_graph_a8e6e316fc6741c9a45328c4026013e44_icgraph" id="aclass_graph_a8e6e316fc6741c9a45328c4026013e44_icgraph">
<area shape="rect" title="Adds a queued modification to the specified element." alt="" coords="469,35,591,61"/>
<area shape="rect" href="class_knowledge_parsing.html#ae54736a1c6f3be5178d575f719757c59" title="Whenever a knowledge item is apart of a message, the relavant link in the knowledge network is set to..." alt="" coords="207,5,421,32"/>
<area shape="rect" href="class_social___media.html#a5701c85fd5b4cbc00700026e94ea3a6b" title="Each users decides whether to unfollow any other user." alt="" coords="239,57,389,98"/>
<area shape="rect" href="class_social___media.html#a289b460c2fde5969469a15893ae2bdf8" title="Feeds are updated, the social media will recommend users to follow, and users can decide to unfollow ..." alt="" coords="5,64,159,91"/>
</map>
</div>

</div>
</div>
<a id="aafd874823e88cda2367254f53f20f989" name="aafd874823e88cda2367254f53f20f989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd874823e88cda2367254f53f20f989">&#9670;&nbsp;</a></span>at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T &amp; <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to link value the iterator points to. </p>
<p >A hard examine is done for the entry in which if there is not a physical entry present, an entry is added at that element and the default value is copied into it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator that determines which element is accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element the iterator points to. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(1); it != mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(it) = it.col();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(1); it != mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_html_ae273f9fe0787d9140d32390db44513a0"><div class="ttname"><a href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">Graph::at</a></div><div class="ttdeci">virtual T &amp; at(unsigned int row, unsigned int col)</div><div class="ttdoc">Gets a reference to the specified link value.</div><div class="ttdef"><b>Definition:</b> Graph.h:980</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 1: 0 1 2 3 </pre> <p ><b>Complexity</b></p>
<p >Constant.</p>
<p ><b>Iterator validity</b></p>
<p >The submitted iterator will always remain valid. Other iterators iterating over the same row or column may no longer be valid.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if <a class="el" href="class_graph__iterator.html#aeb0b40e61c8b389254e6d127f43d2f2a" title="Depending on implementation, returns either row or col.">Graph_iterator::index</a> is equal to <a class="el" href="class_graph__iterator.html#a5b7b52b5204a25c0d180a80f70d4b9fd" title="Returns the maximum value that Construct can return.">Graph_iterator::max</a>. </p>

</div>
</div>
<a id="a2ea192ad83b79ba495919afebbadf133" name="a2ea192ad83b79ba495919afebbadf133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea192ad83b79ba495919afebbadf133">&#9670;&nbsp;</a></span>at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a values and either sets the entry to that value or removes the entry if the submitted value is equal to the default value. </p>
<p >If the submitted value does not equal the default value, a hard examine is done for the entry in which if there is not a physical entry present, an entry is added and the submitted value is coppied into that entry. If the submitted value does equal the default value, that entry is erased if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator that determines which element is accessed. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be inserted in that element. </td></tr>
  </table>
  </dd>
</dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(1); it != mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(it, it.col());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(1); it != mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 1: 0 1 2 3 </pre> <p ><b>Complexity</b></p>
<p >Constant.</p>
<p ><b>Iterator validity</b></p>
<p >The submitted iterator will always remain valid. Other iterators iterating over the same row or column may no longer be valid.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if <a class="el" href="class_graph__iterator.html#aeb0b40e61c8b389254e6d127f43d2f2a" title="Depending on implementation, returns either row or col.">Graph_iterator::index</a> is equal to <a class="el" href="class_graph__iterator.html#a5b7b52b5204a25c0d180a80f70d4b9fd" title="Returns the maximum value that Construct can return.">Graph_iterator::max</a>. </p>

</div>
</div>
<a id="ae273f9fe0787d9140d32390db44513a0" name="ae273f9fe0787d9140d32390db44513a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae273f9fe0787d9140d32390db44513a0">&#9670;&nbsp;</a></span>at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T &amp; <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the specified link value. </p>
<p >A hard examine is done for the entry in which if there is not a physical entry present, an entry is added at that location and the default value is copied into it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row index of the desired element. </td></tr>
    <tr><td class="paramname">col</td><td>Column index of the desired element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the desired element. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,1) = 4;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,2) = 9;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,3) = 3;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(1); it != mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 1: 1 4 9 3 </pre> <p ><b>Complexity</b></p>
<p >If both source and target dimension are dense, constant. If a dimension is sparse, a binary search is used to locate the correct row and/or column, which individual takes O(log n) based on the number of real rows/columns.</p>
<p ><b>Iterator validity</b></p>
<p >If an entry was not inserted at the specified element, all iterators remain valid. Otherwise depending on user defined dimension density, iterators before or at the entry may not be valid.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if either <em>row</em> or <em>col</em> is out of bounds of the source and target nodeset, respectively. <br  />
 </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_ae273f9fe0787d9140d32390db44513a0_icgraph.png" border="0" usemap="#aclass_graph_ae273f9fe0787d9140d32390db44513a0_icgraph" alt=""/></div>
<map name="aclass_graph_ae273f9fe0787d9140d32390db44513a0_icgraph" id="aclass_graph_ae273f9fe0787d9140d32390db44513a0_icgraph">
<area shape="rect" title="Gets a reference to the specified link value." alt="" coords="439,183,515,209"/>
<area shape="rect" href="class_subscription.html#a160479cbf6c748cf4578badef3dbbd93" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="234,5,381,32"/>
<area shape="rect" href="class_beliefs.html#a6dce93ef717ea1b501fc196b7717f46d" title="Function called after the communicate functions in a simulation cycle." alt="" coords="250,56,365,83"/>
<area shape="rect" href="class_grand_interaction.html#a0892b33d56329bf3d31caebeb65b36a8" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="5,107,176,133"/>
<area shape="rect" href="class_forget.html#ac9c385528591374b4984ee81e7351cb9" title="Function called after the communicate functions in a simulation cycle." alt="" coords="251,157,363,184"/>
<area shape="rect" href="class_knowledge_trust.html#add8eff26972cbea7949f2d1be524398f" title="Updates each agent&#39;s knowledge trust based on the agent&#39;s transactive memory." alt="" coords="224,208,391,235"/>
<area shape="rect" href="class_location.html#a79eb57c1c46c13cc4f2f65dcf174562c" title="Function called after the communicate functions in a simulation cycle." alt="" coords="245,259,369,285"/>
<area shape="rect" href="class_tasks.html#a76e4b13a54668969f96291652f678fb3" title="Function called after the communicate functions in a simulation cycle." alt="" coords="252,309,363,336"/>
<area shape="rect" href="class_forget.html#a2809a7a2becb4a6c1c88360db2798757" title="Function called after the update functions in a simulation cycle." alt="" coords="235,360,380,387"/>
</map>
</div>

</div>
</div>
<a id="a03f20d992e0af999c8aea5bbd634a8ba" name="a03f20d992e0af999c8aea5bbd634a8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f20d992e0af999c8aea5bbd634a8ba">&#9670;&nbsp;</a></span>at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a values and either sets the entry to that value or removes the entry if the submitted value is equal to the default value. </p>
<p >If the submitted value does not equal the default value, a hard examine is done for the entry in which if there is not a physical entry present, an entry is added and the submitted value is coppied into that entry. If the submitted value does equal the default value, that entry is erased if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row index of the desired element. </td></tr>
    <tr><td class="paramname">col</td><td>Column index of the desired element. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be inserted in that element. </td></tr>
  </table>
  </dd>
</dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1, 1, 4);</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1, 2, 9);</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1, 0, 0);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(1); it != mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 1: 0 4 9 0 </pre> <p ><b>Complexity</b></p>
<p >If both source and target dimension are dense, constant. If a dimension is sparse, a binary search is used to locate the correct row and/or column, which individually takes O(log n) based on the number of real rows/columns.</p>
<p ><b>Iterator validity</b></p>
<p >If an entry was not inserted at the specified element, all iterators remain valid. Otherwise depending on user defined dimension density, iterators before or at the entry may not be valid.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if either <em>row</em> or col is out of bounds of the source and target nodeset, respectively. <br  />
 </p>

</div>
</div>
<a id="a6ffc5fc35bab3a020e5e13eb6948184e" name="a6ffc5fc35bab3a020e5e13eb6948184e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffc5fc35bab3a020e5e13eb6948184e">&#9670;&nbsp;</a></span>begin_cols() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::begin_cols </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a> pointing to the specified column in the data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_index</td><td>Column index the returned iterator points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a> pointing to the specified column in the data structure. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1col__begin__iterator.html">Graph&lt;int&gt;::col_begin_iterator</a> cols = mygraph-&gt;<a class="code hl_function" href="class_graph.html#a5822222bd7e2c2c5235ec95240f415bb">begin_cols</a>(1); cols != mygraph-&gt;<a class="code hl_function" href="class_graph.html#ad8c67a1c544522468a7c47b14606d805">end_cols</a>(); ++cols) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;col &quot;</span> &lt;&lt; cols.col() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__col__iterator.html">Graph&lt;int&gt;::full_col_iterator</a> it = cols.full_begin(); it != cols.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_1_1col__begin__iterator_html"><div class="ttname"><a href="class_graph_1_1col__begin__iterator.html">Graph::col_begin_iterator</a></div><div class="ttdoc">An iterator that iterates over the start of each row.</div><div class="ttdef"><b>Definition:</b> Graph.h:870</div></div>
<div class="ttc" id="aclass_graph_1_1full__col__iterator_html"><div class="ttname"><a href="class_graph_1_1full__col__iterator.html">Graph::full_col_iterator</a></div><div class="ttdoc">An iterator that iterates over every row at a constant column.</div><div class="ttdef"><b>Definition:</b> Graph.h:671</div></div>
<div class="ttc" id="aclass_graph_html_a5822222bd7e2c2c5235ec95240f415bb"><div class="ttname"><a href="class_graph.html#a5822222bd7e2c2c5235ec95240f415bb">Graph::begin_cols</a></div><div class="ttdeci">virtual col_begin_iterator begin_cols(void)</div><div class="ttdoc">Returns a col_begin_iterator pointing to the first column in the data structure.</div><div class="ttdef"><b>Definition:</b> Graph.h:2260</div></div>
<div class="ttc" id="aclass_graph_html_ad8c67a1c544522468a7c47b14606d805"><div class="ttname"><a href="class_graph.html#ad8c67a1c544522468a7c47b14606d805">Graph::end_cols</a></div><div class="ttdeci">const Graph_iterator end_cols(void) const</div><div class="ttdoc">Returns a Graph_iterator pointing to the beginning of the after the last column.</div><div class="ttdef"><b>Definition:</b> Graph.cpp:136</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">col 1: 1 0 0 5
col 2: 4 0 2 3
col 3: 2 0 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant if the target dimension is dense. Otherwise a binary search is used to find the beginning of the column.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if col_index is out of bounds of the source nodeset. </p>

</div>
</div>
<a id="a67f5136e81b4c64fcf8722ab8084a47d" name="a67f5136e81b4c64fcf8722ab8084a47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f5136e81b4c64fcf8722ab8084a47d">&#9670;&nbsp;</a></span>begin_cols() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::begin_cols </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a> pointing to the specified column in the data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_index</td><td>Row index the returned iterator points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a> pointing to the specified column in the data structure. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* const_mygraph = mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1const__col__begin__iterator.html">Graph&lt;int&gt;::const_col_begin_iterator</a> cols = const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#a5822222bd7e2c2c5235ec95240f415bb">begin_cols</a>(1); cols != const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#ad8c67a1c544522468a7c47b14606d805">end_cols</a>(); ++cols) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;col &quot;</span> &lt;&lt; cols.col() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1const__full__col__iterator.html">Graph&lt;int&gt;::const_full_col_iterator</a> it = cols.full_begin(); it != cols.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_1_1const__col__begin__iterator_html"><div class="ttname"><a href="class_graph_1_1const__col__begin__iterator.html">Graph::const_col_begin_iterator</a></div><div class="ttdoc">A constant iterator that iterates over the start of each column.</div><div class="ttdef"><b>Definition:</b> Graph.h:821</div></div>
<div class="ttc" id="aclass_graph_1_1const__full__col__iterator_html"><div class="ttname"><a href="class_graph_1_1const__full__col__iterator.html">Graph::const_full_col_iterator</a></div><div class="ttdoc">A constant iterator that iterates over every row at a constant column.</div><div class="ttdef"><b>Definition:</b> Graph.h:624</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">col 1: 1 0 0 5
col 2: 4 0 2 3
col 3: 2 0 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant if the source dimension is dense. Otherwise a binary search is used to find the beginning of the column.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if col_index is out of bounds of the target nodeset. </p>

</div>
</div>
<a id="a5822222bd7e2c2c5235ec95240f415bb" name="a5822222bd7e2c2c5235ec95240f415bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5822222bd7e2c2c5235ec95240f415bb">&#9670;&nbsp;</a></span>begin_cols() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::begin_cols </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a> pointing to the first column in the data structure. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1col__begin__iterator.html">col_begin_iterator</a> pointing to the first column in the data structure. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1col__begin__iterator.html">Graph&lt;int&gt;::col_begin_iterator</a> cols = mygraph-&gt;<a class="code hl_function" href="class_graph.html#a5822222bd7e2c2c5235ec95240f415bb">begin_cols</a>(); cols != mygraph-&gt;<a class="code hl_function" href="class_graph.html#ad8c67a1c544522468a7c47b14606d805">end_cols</a>(); ++cols) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;col &quot;</span> &lt;&lt; cols.col() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__col__iterator.html">Graph&lt;int&gt;::full_col_iterator</a> it = cols.full_begin(); it != cols.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">col 0: 0 1 0 4
col 1: 1 0 0 5
col 2: 4 0 2 3
col 3: 2 0 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >Strong Guarantee: This function never throws exceptions </p>

</div>
</div>
<a id="a8490eb739e0822e3f4a2787012d4ef0b" name="a8490eb739e0822e3f4a2787012d4ef0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8490eb739e0822e3f4a2787012d4ef0b">&#9670;&nbsp;</a></span>begin_cols() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::begin_cols </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a> pointing to the first column in the data structure. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1const__col__begin__iterator.html">const_col_begin_iterator</a> pointing to the first column in the data structure. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* const_mygraph = mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> cols = const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#a5822222bd7e2c2c5235ec95240f415bb">begin_cols</a>(); cols != const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#ad8c67a1c544522468a7c47b14606d805">end_cols</a>(); ++cols) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;col &quot;</span> &lt;&lt; cols.col() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = cols.begin(); it != cols.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">col 0: 0 1 0 4
col 1: 1 0 0 5
col 2: 4 0 2 3
col 3: 2 0 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >Strong Guarantee: This function never throws exceptions. </p>

</div>
</div>
<a id="a3abce6c3ff7af131ff433c71646d17a7" name="a3abce6c3ff7af131ff433c71646d17a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abce6c3ff7af131ff433c71646d17a7">&#9670;&nbsp;</a></span>begin_rows() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::begin_rows </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a> pointing to the specified row in the data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index</td><td>Row index the returned iterator points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a> pointing to the specified row in the data structure. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1row__begin__iterator.html">Graph&lt;int&gt;::row_begin_iterator</a> rows = mygraph-&gt;<a class="code hl_function" href="class_graph.html#aeae45c3cac1d7581052b2ab3a2306772">begin_rows</a>(1); rows != mygraph-&gt;<a class="code hl_function" href="class_graph.html#a74b95cf23e3b86d06f23a9d16c9987e3">end_rows</a>(); ++rows) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;row &quot;</span> &lt;&lt; rows.row() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = rows.full_begin(); it != rows.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_1_1row__begin__iterator_html"><div class="ttname"><a href="class_graph_1_1row__begin__iterator.html">Graph::row_begin_iterator</a></div><div class="ttdoc">An iterator that iterates over the start of each row.</div><div class="ttdef"><b>Definition:</b> Graph.h:561</div></div>
<div class="ttc" id="aclass_graph_html_a74b95cf23e3b86d06f23a9d16c9987e3"><div class="ttname"><a href="class_graph.html#a74b95cf23e3b86d06f23a9d16c9987e3">Graph::end_rows</a></div><div class="ttdeci">const Graph_iterator end_rows(void) const</div><div class="ttdoc">Returns a Graph_iterator pointing to the beginning of the after the last row.</div><div class="ttdef"><b>Definition:</b> Graph.cpp:127</div></div>
<div class="ttc" id="aclass_graph_html_aeae45c3cac1d7581052b2ab3a2306772"><div class="ttname"><a href="class_graph.html#aeae45c3cac1d7581052b2ab3a2306772">Graph::begin_rows</a></div><div class="ttdeci">virtual row_begin_iterator begin_rows(void)</div><div class="ttdoc">Returns a row_begin_iterator pointing to the first row in the data structure.</div><div class="ttdef"><b>Definition:</b> Graph.h:1685</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 1: 1 0 0 0
row 2: 0 0 2 3
row 3: 4 5 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant if the source dimension is dense. Otherwise a binary search is used to find the beginning of the row.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if row_index is out of bounds of the source nodeset. </p>

</div>
</div>
<a id="af9680b901c7756db81bf8bea27c6a89d" name="af9680b901c7756db81bf8bea27c6a89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9680b901c7756db81bf8bea27c6a89d">&#9670;&nbsp;</a></span>begin_rows() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::begin_rows </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">&lt;summary&gt;
Returns a \ref const_row_begin_iterator pointing to the specified row in the data structure.
&lt;/summary&gt;
&lt;param name="row_index"&gt;
</pre><p> / Row index the returned iterator points to. / </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a> pointing to the specified row in the data structure. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* const_mygraph = mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1const__row__begin__iterator.html">Graph&lt;int&gt;::const_row_begin_iterator</a> rows = const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#aeae45c3cac1d7581052b2ab3a2306772">begin_rows</a>(1); rows != const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#a74b95cf23e3b86d06f23a9d16c9987e3">end_rows</a>(); ++rows) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;row &quot;</span> &lt;&lt; rows.row() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1const__full__row__iterator.html">Graph&lt;int&gt;::const_full_row_iterator</a> it = rows.full_begin(); it != rows.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_1_1const__full__row__iterator_html"><div class="ttname"><a href="class_graph_1_1const__full__row__iterator.html">Graph::const_full_row_iterator</a></div><div class="ttdoc">A constant iterator that iterates over every column at a constant row.</div><div class="ttdef"><b>Definition:</b> Graph.h:308</div></div>
<div class="ttc" id="aclass_graph_1_1const__row__begin__iterator_html"><div class="ttname"><a href="class_graph_1_1const__row__begin__iterator.html">Graph::const_row_begin_iterator</a></div><div class="ttdoc">A constant iterator that iterates over the start of each row.</div><div class="ttdef"><b>Definition:</b> Graph.h:507</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">    row 1: 1 0 0 0
    row 2: 0 0 2 3
    row 3: 4 5 3 6</pre> <p ><b>Complexity</b></p>
<p >Constant if the source dimension is dense. Otherwise a binary search is used to find the beginning of the row.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if row_index is out of bounds of the source nodeset. </p>

</div>
</div>
<a id="aeae45c3cac1d7581052b2ab3a2306772" name="aeae45c3cac1d7581052b2ab3a2306772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae45c3cac1d7581052b2ab3a2306772">&#9670;&nbsp;</a></span>begin_rows() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::begin_rows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a> pointing to the first row in the data structure. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1row__begin__iterator.html">row_begin_iterator</a> pointing to the first row in the data structure. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1row__begin__iterator.html">Graph&lt;int&gt;::row_begin_iterator</a> rows = mygraph-&gt;<a class="code hl_function" href="class_graph.html#aeae45c3cac1d7581052b2ab3a2306772">begin_rows</a>(); rows != mygraph-&gt;<a class="code hl_function" href="class_graph.html#a74b95cf23e3b86d06f23a9d16c9987e3">end_rows</a>(); ++rows) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;row &quot;</span> &lt;&lt; rows.row() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = rows.full_begin(); it != rows.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 0: 0 1 4 2 
row 1: 1 0 0 0
row 2: 0 0 2 3
row 3: 4 5 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >Strong Guarantee: This function never throws exceptions </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_aeae45c3cac1d7581052b2ab3a2306772_icgraph.png" border="0" usemap="#aclass_graph_aeae45c3cac1d7581052b2ab3a2306772_icgraph" alt=""/></div>
<map name="aclass_graph_aeae45c3cac1d7581052b2ab3a2306772_icgraph" id="aclass_graph_aeae45c3cac1d7581052b2ab3a2306772_icgraph">
<area shape="rect" title="Returns a row_begin_iterator pointing to the first row in the data structure." alt="" coords="461,132,592,159"/>
<area shape="rect" href="class_social___media.html#abe8bfd98128f952616997f9d25ddabf6" title="Gives each user recommended users to follow." alt="" coords="224,5,413,32"/>
<area shape="rect" href="class_beliefs.html#a6dce93ef717ea1b501fc196b7717f46d" title="Function called after the communicate functions in a simulation cycle." alt="" coords="261,56,376,83"/>
<area shape="rect" href="class_grand_interaction.html#a0892b33d56329bf3d31caebeb65b36a8" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="5,107,176,133"/>
<area shape="rect" href="class_forget.html#ac9c385528591374b4984ee81e7351cb9" title="Function called after the communicate functions in a simulation cycle." alt="" coords="263,157,375,184"/>
<area shape="rect" href="class_knowledge_trust.html#add8eff26972cbea7949f2d1be524398f" title="Updates each agent&#39;s knowledge trust based on the agent&#39;s transactive memory." alt="" coords="235,208,402,235"/>
<area shape="rect" href="class_tasks.html#a76e4b13a54668969f96291652f678fb3" title="Function called after the communicate functions in a simulation cycle." alt="" coords="263,259,374,285"/>
<area shape="rect" href="class_social___media.html#a289b460c2fde5969469a15893ae2bdf8" title="Feeds are updated, the social media will recommend users to follow, and users can decide to unfollow ..." alt="" coords="14,5,167,32"/>
</map>
</div>

</div>
</div>
<a id="ac6ad484e474eda1bf856a3b74e258e45" name="ac6ad484e474eda1bf856a3b74e258e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ad484e474eda1bf856a3b74e258e45">&#9670;&nbsp;</a></span>begin_rows() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::begin_rows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a> pointing to the first row in the data structure. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1const__row__begin__iterator.html">const_row_begin_iterator</a> pointing to the row in the data structure. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* const_mygraph = mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> rows = const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#aeae45c3cac1d7581052b2ab3a2306772">begin_rows</a>(); rows != const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#a74b95cf23e3b86d06f23a9d16c9987e3">end_rows</a>(); ++rows) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;row &quot;</span> &lt;&lt; rows.row() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = rows.begin(); it != rows.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 0: 0 1 4 2
row 1: 1 0 0 0
row 2: 0 0 2 3
row 3: 4 5 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >Strong Guarantee: This function never throws exceptions. </p>

</div>
</div>
<a id="a4b2276dcbd31bcebf8152eee2cdfa2c8" name="a4b2276dcbd31bcebf8152eee2cdfa2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2276dcbd31bcebf8152eee2cdfa2c8">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all elements equal to the submitted value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Value that each element is set to. </td></tr>
  </table>
  </dd>
</dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#a4b2276dcbd31bcebf8152eee2cdfa2c8">clear</a>(2);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 0:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(0); it != mygraph-&gt;<a class="code hl_function" href="class_graph.html#af25ece15d9f34295d20774d48694461b">row_end</a>(0); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_html_a4b2276dcbd31bcebf8152eee2cdfa2c8"><div class="ttname"><a href="class_graph.html#a4b2276dcbd31bcebf8152eee2cdfa2c8">Graph::clear</a></div><div class="ttdeci">virtual void clear(const T &amp;data)</div><div class="ttdoc">Set all elements equal to the submitted value.</div><div class="ttdef"><b>Definition:</b> Graph.h:1149</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 0: 2 2 2 2 </pre> <p ><b>Complexity</b></p>
<p >Linear in number of elements in the graph.</p>
<p ><b>Iterator validity</b></p>
<p >All iterators are invalidated unless both dimensions are dense.</p>
<p ><b>Exception Safety</b></p>
<p >Strong Guarantee: This function never throws exceptions. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_a4b2276dcbd31bcebf8152eee2cdfa2c8_icgraph.png" border="0" usemap="#aclass_graph_a4b2276dcbd31bcebf8152eee2cdfa2c8_icgraph" alt=""/></div>
<map name="aclass_graph_a4b2276dcbd31bcebf8152eee2cdfa2c8_icgraph" id="aclass_graph_a4b2276dcbd31bcebf8152eee2cdfa2c8_icgraph">
<area shape="rect" title="Set all elements equal to the submitted value." alt="" coords="148,5,241,32"/>
<area shape="rect" href="class_forget.html#a831f048d2527fa85d7f59ecfd0969786" title="First function called in a simulation cycle." alt="" coords="5,5,100,32"/>
</map>
</div>

</div>
</div>
<a id="a5985b4292f2ac31e8cbc5b0cf74f0235" name="a5985b4292f2ac31e8cbc5b0cf74f0235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5985b4292f2ac31e8cbc5b0cf74f0235">&#9670;&nbsp;</a></span>col_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_graph__iterator.html">Graph_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::col_end </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the end of the specified column. </p>
<p >This iterator points to beyond the last piece of data and thus should not be dereferenced. Because all iterators in the <a class="el" href="class_graph.html" title="Data structure for storing graphs/networks.">Graph</a> class are derived from <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a>, they can be compared for equality with a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_index</td><td>Column index the returned iterator points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the end of a column. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1col__begin__iterator.html">Graph&lt;int&gt;::col_begin_iterator</a> cols = mygraph-&gt;<a class="code hl_function" href="class_graph.html#a5822222bd7e2c2c5235ec95240f415bb">begin_cols</a>(1); cols != mygraph-&gt;<a class="code hl_function" href="class_graph.html#ad8c67a1c544522468a7c47b14606d805">end_cols</a>(); ++cols) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;col &quot;</span> &lt;&lt; cols.col() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__col__iterator.html">Graph&lt;int&gt;::full_col_iterator</a> it = colss.full_begin(); it != cols.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">col 1: 1 0 0 5
col 2: 4 0 2 3
col 3: 2 0 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if col_index is out of bounds of the target nodeset. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_a5985b4292f2ac31e8cbc5b0cf74f0235_icgraph.png" border="0" usemap="#aclass_graph_a5985b4292f2ac31e8cbc5b0cf74f0235_icgraph" alt=""/></div>
<map name="aclass_graph_a5985b4292f2ac31e8cbc5b0cf74f0235_icgraph" id="aclass_graph_a5985b4292f2ac31e8cbc5b0cf74f0235_icgraph">
<area shape="rect" title="Returns a Graph_iterator pointing to the end of the specified column." alt="" coords="671,165,781,192"/>
<area shape="rect" href="structmedia__user.html#a45bcdacb4375f6ce8d374c86b25917ab" title="Mentions are added to the event if the event is a post by randomly selecting a followee." alt="" coords="444,5,623,32"/>
<area shape="rect" href="class_subscription.html#a160479cbf6c748cf4578badef3dbbd93" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="460,56,607,83"/>
<area shape="rect" href="class_location.html#a79eb57c1c46c13cc4f2f65dcf174562c" title="Function called after the communicate functions in a simulation cycle." alt="" coords="471,107,595,133"/>
<area shape="rect" href="class_social___media.html#a5867959593031ca7856fed25820410e9" title="Computes the Jaccard Similarity in the follower network between the two agent indexes." alt="" coords="458,158,609,199"/>
<area shape="rect" href="class_subscription.html#ab05d3aed151249d20c43f4d66e81a535" title="First function called in a simulation cycle." alt="" coords="468,224,599,251"/>
<area shape="rect" href="class_location.html#a1ff84144cc863e5cad6ee600fa241aca" title="First function called in a simulation cycle." alt="" coords="480,275,587,301"/>
<area shape="rect" href="class_social___media.html#a1ee64ec8b017616dadb313d86b697358" title="Updates each user&#39;s feeds." alt="" coords="228,293,375,334"/>
<area shape="rect" href="structmedia__user.html#a4224843d1b7973e6169d0f1063a8e601" title="With proabability media_user::pqu creates a quote to the event." alt="" coords="237,5,366,32"/>
<area shape="rect" href="class_social___media.html#abe8bfd98128f952616997f9d25ddabf6" title="Gives each user recommended users to follow." alt="" coords="207,165,396,192"/>
<area shape="rect" href="structmedia__user.html#a9e82830bd5576a2f1d71be3eb7801de1" title="Returns true if this user decides to unfollow an agent when called." alt="" coords="214,216,389,243"/>
<area shape="rect" href="class_social___media.html#a289b460c2fde5969469a15893ae2bdf8" title="Feeds are updated, the social media will recommend users to follow, and users can decide to unfollow ..." alt="" coords="5,245,159,272"/>
</map>
</div>

</div>
</div>
<a id="ad8c67a1c544522468a7c47b14606d805" name="ad8c67a1c544522468a7c47b14606d805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c67a1c544522468a7c47b14606d805">&#9670;&nbsp;</a></span>end_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_graph__iterator.html">Graph_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::end_cols </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the beginning of the after the last column. </p>
<p >Because all iterators in the <a class="el" href="class_graph.html" title="Data structure for storing graphs/networks.">Graph</a> class are derived from <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a>, they can be compared for equality with a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing element (col_size, 0). </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1col__begin__iterator.html">Graph&lt;int&gt;::col_begin_iterator</a> cols = mygraph-&gt;<a class="code hl_function" href="class_graph.html#a5822222bd7e2c2c5235ec95240f415bb">begin_cols</a>(1); cols != mygraph-&gt;<a class="code hl_function" href="class_graph.html#ad8c67a1c544522468a7c47b14606d805">end_cols</a>(); ++cols) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;col &quot;</span> &lt;&lt; cols.col() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__col__iterator.html">Graph&lt;int&gt;::full_col_iterator</a> it = cols.full_begin(); it != cols.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">col 1: 1 0 0 5
col 2: 4 0 2 3
col 3: 2 0 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >Strong Guarantee: This function never throws exceptions. </p>

</div>
</div>
<a id="a74b95cf23e3b86d06f23a9d16c9987e3" name="a74b95cf23e3b86d06f23a9d16c9987e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b95cf23e3b86d06f23a9d16c9987e3">&#9670;&nbsp;</a></span>end_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_graph__iterator.html">Graph_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::end_rows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the beginning of the after the last row. </p>
<p >Because all iterators in the <a class="el" href="class_graph.html" title="Data structure for storing graphs/networks.">Graph</a> class are derived from <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a>, they can be compared for equality with a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing element (row_size, 0). </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1row__begin__iterator.html">Graph&lt;int&gt;::row_begin_iterator</a> rows = mygraph-&gt;<a class="code hl_function" href="class_graph.html#aeae45c3cac1d7581052b2ab3a2306772">begin_rows</a>(1); rows != mygraph-&gt;<a class="code hl_function" href="class_graph.html#a74b95cf23e3b86d06f23a9d16c9987e3">end_rows</a>(); ++rows) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;row &quot;</span> &lt;&lt; rows.row() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = rows.full_begin(); it != rows.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 1: 1 0 0 0
row 2: 0 0 2 3
row 3: 4 5 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >Strong Guarantee: This function never throws exceptions. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_a74b95cf23e3b86d06f23a9d16c9987e3_icgraph.png" border="0" usemap="#aclass_graph_a74b95cf23e3b86d06f23a9d16c9987e3_icgraph" alt=""/></div>
<map name="aclass_graph_a74b95cf23e3b86d06f23a9d16c9987e3_icgraph" id="aclass_graph_a74b95cf23e3b86d06f23a9d16c9987e3_icgraph">
<area shape="rect" title="Returns a Graph_iterator pointing to the beginning of the after the last row." alt="" coords="461,132,581,159"/>
<area shape="rect" href="class_social___media.html#abe8bfd98128f952616997f9d25ddabf6" title="Gives each user recommended users to follow." alt="" coords="224,5,413,32"/>
<area shape="rect" href="class_beliefs.html#a6dce93ef717ea1b501fc196b7717f46d" title="Function called after the communicate functions in a simulation cycle." alt="" coords="261,56,376,83"/>
<area shape="rect" href="class_grand_interaction.html#a0892b33d56329bf3d31caebeb65b36a8" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="5,107,176,133"/>
<area shape="rect" href="class_forget.html#ac9c385528591374b4984ee81e7351cb9" title="Function called after the communicate functions in a simulation cycle." alt="" coords="263,157,375,184"/>
<area shape="rect" href="class_knowledge_trust.html#add8eff26972cbea7949f2d1be524398f" title="Updates each agent&#39;s knowledge trust based on the agent&#39;s transactive memory." alt="" coords="235,208,402,235"/>
<area shape="rect" href="class_tasks.html#a76e4b13a54668969f96291652f678fb3" title="Function called after the communicate functions in a simulation cycle." alt="" coords="263,259,374,285"/>
<area shape="rect" href="class_social___media.html#a289b460c2fde5969469a15893ae2bdf8" title="Feeds are updated, the social media will recommend users to follow, and users can decide to unfollow ..." alt="" coords="14,5,167,32"/>
</map>
</div>

</div>
</div>
<a id="aeb687de64b37c4454395f226e65af57e" name="aeb687de64b37c4454395f226e65af57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb687de64b37c4454395f226e65af57e">&#9670;&nbsp;</a></span>examine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T &amp; <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::examine </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a constant reference to the specified element. </p>
<p >A soft examine is done for the element in which if the element is not present, the default value is returned. The constant reference can not be modified as the default value is a constant in the case its returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row index of the desired element. </td></tr>
    <tr><td class="paramname">col</td><td>Column index of the desired element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the desired element. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; mygraph-&gt;<a class="code hl_variable" href="class_graph___interface.html#a5e8fb36cc7c750c01fbe7b5e60283d7e">row_size</a>; i++) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;row &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; col 0: &quot;</span> &lt;&lt; mygraph-&gt;<a class="code hl_function" href="class_graph.html#aeb687de64b37c4454395f226e65af57e">examine</a>(i,0) &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph___interface_html_a5e8fb36cc7c750c01fbe7b5e60283d7e"><div class="ttname"><a href="class_graph___interface.html#a5e8fb36cc7c750c01fbe7b5e60283d7e">Graph_Interface::row_size</a></div><div class="ttdeci">const unsigned int row_size</div><div class="ttdoc">The number of rows in the data structure. Equalivilent to the size of the source nodeset.</div><div class="ttdef"><b>Definition:</b> Graph.h:89</div></div>
<div class="ttc" id="aclass_graph_html_aeb687de64b37c4454395f226e65af57e"><div class="ttname"><a href="class_graph.html#aeb687de64b37c4454395f226e65af57e">Graph::examine</a></div><div class="ttdeci">virtual const T &amp; examine(unsigned int row, unsigned int col) const</div><div class="ttdoc">Gets a constant reference to the specified element.</div><div class="ttdef"><b>Definition:</b> Graph.h:1102</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 0 col 0: 0
row 1 col 0: 1
row 2 col 0: 0
row 3 col 0: 4
</pre> <p ><b>Complexity</b></p>
<p >If both source and target dimension are dense, constant. If a dimension is sparse, a binary search is used to locate the correct row and/or column, which individual takes O(log n) based on the number of real rows/columns.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if either row or col is out of bounds of the source and target nodeset, respectively. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_aeb687de64b37c4454395f226e65af57e_icgraph.png" border="0" usemap="#aclass_graph_aeb687de64b37c4454395f226e65af57e_icgraph" alt=""/></div>
<map name="aclass_graph_aeb687de64b37c4454395f226e65af57e_icgraph" id="aclass_graph_aeb687de64b37c4454395f226e65af57e_icgraph">
<area shape="rect" title="Gets a constant reference to the specified element." alt="" coords="455,300,569,327"/>
<area shape="rect" href="class_subscription.html#a160479cbf6c748cf4578badef3dbbd93" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="242,5,389,32"/>
<area shape="rect" href="class_forget.html#ac9c385528591374b4984ee81e7351cb9" title="Function called after the communicate functions in a simulation cycle." alt="" coords="259,56,371,83"/>
<area shape="rect" href="class_tasks.html#a76e4b13a54668969f96291652f678fb3" title="Function called after the communicate functions in a simulation cycle." alt="" coords="260,107,371,133"/>
<area shape="rect" href="structmedia__user.html#a86e1593193ee0aad0aa553daf0c476a0" title="Returns true if this user decides to follow an agent when called." alt="" coords="235,157,396,184"/>
<area shape="rect" href="structmedia__user.html#a12222e7deffbf643531d989af4229384" title="Gets the trust of the knowledge index." alt="" coords="241,208,389,235"/>
<area shape="rect" href="class_graph_1_1const__full__row__iterator.html#aef33a07791abf766c945623a4dae6350" title="Returns target dimension size." alt="" coords="239,259,391,301"/>
<area shape="rect" href="class_graph_1_1row__begin__iterator.html#a43a7e033834c1f340a23e3e9f15a9e24" title="Returns source dimension size." alt="" coords="245,325,385,366"/>
<area shape="rect" href="class_location.html#a1ff84144cc863e5cad6ee600fa241aca" title="First function called in a simulation cycle." alt="" coords="262,391,369,417"/>
<area shape="rect" href="structmedia__user.html#a9e82830bd5576a2f1d71be3eb7801de1" title="Returns true if this user decides to unfollow an agent when called." alt="" coords="228,441,403,468"/>
<area shape="rect" href="class_knowledge_learning_difficulty.html#a232050c10f20635749e546a3952b5a56" title="Function called after the think functions in a simulation cycle." alt="" coords="224,493,407,534"/>
<area shape="rect" href="class_knowledge_trust.html#a5030265aa9707a7b05eb14dd6d86b580" title="Add knowledge trust to knowledge items in messages if they do not already include them." alt="" coords="235,559,396,585"/>
<area shape="rect" href="class_mail.html#aaf3c6cea2fb7e7af2bb608d44a7de34f" title="Function called after the think functions in a simulation cycle." alt="" coords="269,609,362,636"/>
<area shape="rect" href="class_grand_interaction.html#a0892b33d56329bf3d31caebeb65b36a8" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="5,107,176,133"/>
</map>
</div>

</div>
</div>
<a id="a3abbd42d0e097f3c67df57fe2646fc57" name="a3abbd42d0e097f3c67df57fe2646fc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abbd42d0e097f3c67df57fe2646fc57">&#9670;&nbsp;</a></span>full_col_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1full__col__iterator.html">full_col_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::full_col_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1full__col__iterator.html">full_col_iterator</a> pointing to beginning of the specified column </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_index</td><td>Column index the returned iterator points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1full__col__iterator.html">full_col_iterator</a> pointing to the beginning of the column at index col_index. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,1) = 4;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,2) = 9;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,3) = 3;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;col 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__col__iterator.html">Graph&lt;int&gt;::full_col_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#a3abbd42d0e097f3c67df57fe2646fc57">full_col_begin</a>(1); it != mygraph-&gt;end_col(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_html_a3abbd42d0e097f3c67df57fe2646fc57"><div class="ttname"><a href="class_graph.html#a3abbd42d0e097f3c67df57fe2646fc57">Graph::full_col_begin</a></div><div class="ttdeci">virtual full_col_iterator full_col_begin(unsigned int col_index)</div><div class="ttdoc">Returns a full_col_iterator pointing to beginning of the specified column</div><div class="ttdef"><b>Definition:</b> Graph.h:2031</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">col 1: 1 4 0 5 </pre> <p ><b>Complexity</b></p>
<p >If the target dimension is dense, constant. Otherwise a binary search is used to find the beginning of a column.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if col_index is out of bounds of the target nodeset. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_a3abbd42d0e097f3c67df57fe2646fc57_icgraph.png" border="0" usemap="#aclass_graph_a3abbd42d0e097f3c67df57fe2646fc57_icgraph" alt=""/></div>
<map name="aclass_graph_a3abbd42d0e097f3c67df57fe2646fc57_icgraph" id="aclass_graph_a3abbd42d0e097f3c67df57fe2646fc57_icgraph">
<area shape="rect" title="Returns a full_col_iterator pointing to beginning of the specified column" alt="" coords="643,35,785,61"/>
<area shape="rect" href="class_location.html#a79eb57c1c46c13cc4f2f65dcf174562c" title="Function called after the communicate functions in a simulation cycle." alt="" coords="457,5,581,32"/>
<area shape="rect" href="class_social___media.html#a5867959593031ca7856fed25820410e9" title="Computes the Jaccard Similarity in the follower network between the two agent indexes." alt="" coords="444,57,595,98"/>
<area shape="rect" href="class_social___media.html#abe8bfd98128f952616997f9d25ddabf6" title="Gives each user recommended users to follow." alt="" coords="207,39,396,65"/>
<area shape="rect" href="structmedia__user.html#a9e82830bd5576a2f1d71be3eb7801de1" title="Returns true if this user decides to unfollow an agent when called." alt="" coords="214,89,389,116"/>
<area shape="rect" href="class_social___media.html#a289b460c2fde5969469a15893ae2bdf8" title="Feeds are updated, the social media will recommend users to follow, and users can decide to unfollow ..." alt="" coords="5,39,159,65"/>
</map>
</div>

</div>
</div>
<a id="a819f95b807fc0ef9c13ab40eaf08f737" name="a819f95b807fc0ef9c13ab40eaf08f737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819f95b807fc0ef9c13ab40eaf08f737">&#9670;&nbsp;</a></span>full_col_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1const__full__col__iterator.html">const_full_col_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::full_col_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1const__full__col__iterator.html">const_full_col_iterator</a> pointing to beginning of the specified column </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_index</td><td>Column index the returned iterator points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1const__full__col__iterator.html">const_full_col_iterator</a> pointing to the beginning of the column at index col_index. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,1) = 4;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,2) = 9;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,3) = 3;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* const_mygraph = mygraph;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;col 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1const__full__col__iterator.html">Graph&lt;int&gt;::const_full_col_iterator</a> it = const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#a3abbd42d0e097f3c67df57fe2646fc57">full_col_begin</a>(1); it != const_mygraph-&gt;end_col(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">col 1: 1 4 0 5 </pre> <p ><b>Complexity</b></p>
<p >If the source dimension is dense, constant. Otherwise a binary search is used to find the beginning of a column.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if col_index is out of bounds of the target nodeset. </p>

</div>
</div>
<a id="ab80f4c0d626d78ca05cce2e644cb4a59" name="ab80f4c0d626d78ca05cce2e644cb4a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80f4c0d626d78ca05cce2e644cb4a59">&#9670;&nbsp;</a></span>full_row_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::full_row_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a> pointing to beginning of the specified row </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index</td><td>Row index the returned iterator points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1full__row__iterator.html">full_row_iterator</a> pointing to the beginning of the row at index row_index. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,1) = 4;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,2) = 9;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,3) = 3;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(1); it != mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 1: 1 4 9 3 </pre> <p ><b>Complexity</b></p>
<p >If the source dimension is dense, constant. Otherwise a binary search is used to find the beginning of a row.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if row_index is out of bounds of the source nodeset. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_ab80f4c0d626d78ca05cce2e644cb4a59_icgraph.png" border="0" usemap="#aclass_graph_ab80f4c0d626d78ca05cce2e644cb4a59_icgraph" alt=""/></div>
<map name="aclass_graph_ab80f4c0d626d78ca05cce2e644cb4a59_icgraph" id="aclass_graph_ab80f4c0d626d78ca05cce2e644cb4a59_icgraph">
<area shape="rect" title="Returns a full_row_iterator pointing to beginning of the specified row" alt="" coords="215,31,361,57"/>
<area shape="rect" href="class_location.html#a79eb57c1c46c13cc4f2f65dcf174562c" title="Function called after the communicate functions in a simulation cycle." alt="" coords="24,5,148,32"/>
<area shape="rect" href="structmedia__user.html#a86e1593193ee0aad0aa553daf0c476a0" title="Returns true if this user decides to follow an agent when called." alt="" coords="5,56,167,83"/>
</map>
</div>

</div>
</div>
<a id="a546de7e197b5a6fae846d03de1fa1efb" name="a546de7e197b5a6fae846d03de1fa1efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546de7e197b5a6fae846d03de1fa1efb">&#9670;&nbsp;</a></span>full_row_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1const__full__row__iterator.html">const_full_row_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::full_row_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1const__full__row__iterator.html">const_full_row_iterator</a> pointing to beginning of the specified row </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index</td><td>Row index the returned iterator points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1const__full__row__iterator.html">const_full_row_iterator</a> pointing to the beginning of the row at index row_index. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,1) = 4;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,2) = 9;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,3) = 3;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* const_mygraph = mygraph;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1const__full__row__iterator.html">Graph&lt;int&gt;::const_full_row_iterator</a> it = const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(1); it != const_mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 1: 1 4 9 3 </pre> <p ><b>Complexity</b></p>
<p >If the source dimension is dense, constant. Otherwise a binary search is used to find the beginning of a row.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if row_index is out of bounds of the source nodeset. </p>

</div>
</div>
<a id="adddc3bdced41c8dcb5b93733dcb43d8a" name="adddc3bdced41c8dcb5b93733dcb43d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddc3bdced41c8dcb5b93733dcb43d8a">&#9670;&nbsp;</a></span>push_deltas()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::push_deltas </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies all queued modifications created by the <a class="el" href="class_graph.html#a8e6e316fc6741c9a45328c4026013e44">add_delta</a> function. </p>
<p >Modifications are applied starting with the first modification queued. If two modifications are queued for the same element, the most recent delta overwrites the older delta. If a modification would set an element to equal the default value, the element is instead removed. After all modifications have been made, the queue of deltas is cleared. </p>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#a8e6e316fc6741c9a45328c4026013e44">add_delta</a>(0, 0, 1);</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#adddc3bdced41c8dcb5b93733dcb43d8a">push_deltas</a>();</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;row 0:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ab80f4c0d626d78ca05cce2e644cb4a59">full_row_begin</a>(0); it != mygraph-&gt;<a class="code hl_function" href="class_graph.html#af25ece15d9f34295d20774d48694461b">row_end</a>(0); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 0: 1 1 4 2 </pre> <p ><b>Complexity</b></p>
<p >Each modification requires an <a class="el" href="class_graph.html#a03f20d992e0af999c8aea5bbd634a8ba">at(unsigned int, unsigned int, const T&amp;)</a> call which can be O(1) or O(log n) depending on dimension density. This call is done for every queued modification.</p>
<p ><b>Iterator validity</b></p>
<p >If densities aren't sparse some iterators may be invalid based on set of deltas used</p>
<p ><b>Exception Safety</b></p>
<p >Strong Guarantee: This function never throws exceptions. </p>

<p>Reimplemented from <a class="el" href="class_graph___interface.html#a87724335d73eb3e1960f76ad4cd6a822">Graph_Interface</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_adddc3bdced41c8dcb5b93733dcb43d8a_icgraph.png" border="0" usemap="#aclass_graph_adddc3bdced41c8dcb5b93733dcb43d8a_icgraph" alt=""/></div>
<map name="aclass_graph_adddc3bdced41c8dcb5b93733dcb43d8a_icgraph" id="aclass_graph_adddc3bdced41c8dcb5b93733dcb43d8a_icgraph">
<area shape="rect" title="Applies all queued modifications created by the add_delta function." alt="" coords="207,5,341,32"/>
<area shape="rect" href="class_social___media.html#a289b460c2fde5969469a15893ae2bdf8" title="Feeds are updated, the social media will recommend users to follow, and users can decide to unfollow ..." alt="" coords="5,5,159,32"/>
</map>
</div>

</div>
</div>
<a id="af25ece15d9f34295d20774d48694461b" name="af25ece15d9f34295d20774d48694461b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25ece15d9f34295d20774d48694461b">&#9670;&nbsp;</a></span>row_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_graph__iterator.html">Graph_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::row_end </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the end of the specified row. </p>
<p >This iterator points to beyond the last piece of data and thus should not be dereferenced. Because all iterators in the <a class="el" href="class_graph.html" title="Data structure for storing graphs/networks.">Graph</a> class are derived from <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a>, they can be compared for equality with a <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index</td><td>Row index the returned iterator points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph__iterator.html" title="Parent class for Graph&#39;s iterators.">Graph_iterator</a> pointing to the end of a row. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_graph_1_1row__begin__iterator.html">Graph&lt;int&gt;::row_begin_iterator</a> rows = mygraph-&gt;<a class="code hl_function" href="class_graph.html#aeae45c3cac1d7581052b2ab3a2306772">begin_rows</a>(1); rows != mygraph-&gt;<a class="code hl_function" href="class_graph.html#a74b95cf23e3b86d06f23a9d16c9987e3">end_rows</a>(); ++rows) {</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;row &quot;</span> &lt;&lt; rows.row() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1full__row__iterator.html">Graph&lt;int&gt;::full_row_iterator</a> it = rows.full_begin(); it != rows.end(); ++it) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">row 1: 1 0 0 0
row 2: 0 0 2 3
row 3: 4 5 3 6
</pre> <p ><b>Complexity</b></p>
<p >Constant</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if row_index is out of bounds of the source nodeset. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_af25ece15d9f34295d20774d48694461b_icgraph.png" border="0" usemap="#aclass_graph_af25ece15d9f34295d20774d48694461b_icgraph" alt=""/></div>
<map name="aclass_graph_af25ece15d9f34295d20774d48694461b_icgraph" id="aclass_graph_af25ece15d9f34295d20774d48694461b_icgraph">
<area shape="rect" title="Returns a Graph_iterator pointing to the end of the specified row." alt="" coords="433,199,547,225"/>
<area shape="rect" href="class_location.html#a79eb57c1c46c13cc4f2f65dcf174562c" title="Function called after the communicate functions in a simulation cycle." alt="" coords="243,5,367,32"/>
<area shape="rect" href="class_tasks.html#a76e4b13a54668969f96291652f678fb3" title="Function called after the communicate functions in a simulation cycle." alt="" coords="249,56,360,83"/>
<area shape="rect" href="structmedia__user.html#a86e1593193ee0aad0aa553daf0c476a0" title="Returns true if this user decides to follow an agent when called." alt="" coords="224,107,385,133"/>
<area shape="rect" href="structmedia__user.html#ab073845b9e391fc621cacdafb7c0f55e" title="The user adds a number of post events based on media_user::pdp." alt="" coords="231,158,378,199"/>
<area shape="rect" href="class_social___media.html#a5701c85fd5b4cbc00700026e94ea3a6b" title="Each users decides whether to unfollow any other user." alt="" coords="230,223,379,265"/>
<area shape="rect" href="class_location.html#a1ff84144cc863e5cad6ee600fa241aca" title="First function called in a simulation cycle." alt="" coords="251,289,358,316"/>
<area shape="rect" href="class_social___media.html#a692bdc21cbf7165820290fdfcecd39ce" title="Agents read events in their feed and create messages based on the read events." alt="" coords="237,340,373,367"/>
<area shape="rect" href="class_mail.html#aaf3c6cea2fb7e7af2bb608d44a7de34f" title="Function called after the think functions in a simulation cycle." alt="" coords="258,391,351,417"/>
<area shape="rect" href="class_grand_interaction.html#a0892b33d56329bf3d31caebeb65b36a8" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="5,56,176,83"/>
<area shape="rect" href="class_social___media.html#a289b460c2fde5969469a15893ae2bdf8" title="Feeds are updated, the social media will recommend users to follow, and users can decide to unfollow ..." alt="" coords="14,231,167,257"/>
</map>
</div>

</div>
</div>
<a id="a3d4dd648ff233ba66033809b251394c4" name="a3d4dd648ff233ba66033809b251394c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4dd648ff233ba66033809b251394c4">&#9670;&nbsp;</a></span>sparse_col_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1sparse__col__iterator.html">sparse_col_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::sparse_col_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>skip_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1sparse__col__iterator.html" title="An iterator that iterates over each element whose value does not equal the skip value.">Graph::sparse_col_iterator</a> pointing to beginning of the specified column </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_index</td><td>Column index the returned iterator points to. </td></tr>
    <tr><td class="paramname">skip_data</td><td>Element values the iterator will skip over. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1sparse__col__iterator.html" title="An iterator that iterates over each element whose value does not equal the skip value.">Graph::sparse_col_iterator</a> pointing to the beginning of the column at index col_index. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;non-zero elements in col 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1sparse__col__iterator.html">Graph&lt;int&gt;::sparse_col_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#a3d4dd648ff233ba66033809b251394c4">sparse_col_begin</a>(1, 0); it != mygraph-&gt;end_col(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_1_1sparse__col__iterator_html"><div class="ttname"><a href="class_graph_1_1sparse__col__iterator.html">Graph::sparse_col_iterator</a></div><div class="ttdoc">An iterator that iterates over each element whose value does not equal the skip value.</div><div class="ttdef"><b>Definition:</b> Graph.h:770</div></div>
<div class="ttc" id="aclass_graph_html_a3d4dd648ff233ba66033809b251394c4"><div class="ttname"><a href="class_graph.html#a3d4dd648ff233ba66033809b251394c4">Graph::sparse_col_begin</a></div><div class="ttdeci">virtual sparse_col_iterator sparse_col_begin(unsigned int col_index, const T &amp;skip_data)</div><div class="ttdoc">Returns a Graph::sparse_col_iterator pointing to beginning of the specified column</div><div class="ttdef"><b>Definition:</b> Graph.h:2145</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">non-zero elements in col 1: 1 5 </pre> <p ><b>Complexity</b></p>
<p >If the source dimension is dense, constant. Otherwise a binary search is used to find the beginning of a column.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if col_index is out of bounds of the target nodeset. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_a3d4dd648ff233ba66033809b251394c4_icgraph.png" border="0" usemap="#aclass_graph_a3d4dd648ff233ba66033809b251394c4_icgraph" alt=""/></div>
<map name="aclass_graph_a3d4dd648ff233ba66033809b251394c4_icgraph" id="aclass_graph_a3d4dd648ff233ba66033809b251394c4_icgraph">
<area shape="rect" title="Returns a Graph::sparse_col_iterator pointing to beginning of the specified column" alt="" coords="433,132,600,159"/>
<area shape="rect" href="structmedia__user.html#a45bcdacb4375f6ce8d374c86b25917ab" title="Mentions are added to the event if the event is a post by randomly selecting a followee." alt="" coords="207,5,385,32"/>
<area shape="rect" href="class_subscription.html#a160479cbf6c748cf4578badef3dbbd93" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="223,56,369,83"/>
<area shape="rect" href="class_subscription.html#ab05d3aed151249d20c43f4d66e81a535" title="First function called in a simulation cycle." alt="" coords="231,107,361,133"/>
<area shape="rect" href="class_location.html#a1ff84144cc863e5cad6ee600fa241aca" title="First function called in a simulation cycle." alt="" coords="243,157,349,184"/>
<area shape="rect" href="class_mail.html#aaf3c6cea2fb7e7af2bb608d44a7de34f" title="Function called after the think functions in a simulation cycle." alt="" coords="249,208,343,235"/>
<area shape="rect" href="class_social___media.html#a1ee64ec8b017616dadb313d86b697358" title="Updates each user&#39;s feeds." alt="" coords="223,259,369,301"/>
<area shape="rect" href="structmedia__user.html#a4224843d1b7973e6169d0f1063a8e601" title="With proabability media_user::pqu creates a quote to the event." alt="" coords="17,5,147,32"/>
<area shape="rect" href="class_social___media.html#a289b460c2fde5969469a15893ae2bdf8" title="Feeds are updated, the social media will recommend users to follow, and users can decide to unfollow ..." alt="" coords="5,267,159,293"/>
</map>
</div>

</div>
</div>
<a id="ac2cd3e90f853b76773711ec80f341643" name="ac2cd3e90f853b76773711ec80f341643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cd3e90f853b76773711ec80f341643">&#9670;&nbsp;</a></span>sparse_col_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1const__sparse__col__iterator.html">const_sparse_col_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::sparse_col_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>skip_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1const__sparse__col__iterator.html" title="A constant iterator that iterates over each element whose value does not equal the skip value.">Graph::const_sparse_col_iterator</a> pointing to beginning of the specified column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_index</td><td>Column index the returned iterator points to. </td></tr>
    <tr><td class="paramname">skip_data</td><td>Element values the iterator will skip over. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1const__sparse__col__iterator.html">const_sparse_col_iterator</a> pointing to the beginning of the column at index col_index. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* const_mygraph = mygraph;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;non-zero elements in col 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1const__sparse__col__iterator.html">Graph&lt;int&gt;::const_sparse_col_iterator</a> it = const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#a3d4dd648ff233ba66033809b251394c4">sparse_col_begin</a>(1, 0); it != const_mygraph-&gt;end_col(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_1_1const__sparse__col__iterator_html"><div class="ttname"><a href="class_graph_1_1const__sparse__col__iterator.html">Graph::const_sparse_col_iterator</a></div><div class="ttdoc">A constant iterator that iterates over each element whose value does not equal the skip value.</div><div class="ttdef"><b>Definition:</b> Graph.h:720</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">non-zero elements in col 1: 1 5 </pre> <p ><b>Complexity</b></p>
<p >If the source dimension is dense, constant. Otherwise a binary search is used to find the beginning of a column.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if col_index is out of bounds of the target nodeset. </p>

</div>
</div>
<a id="ac45c25683e8539f61314e848dd45c8ed" name="ac45c25683e8539f61314e848dd45c8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45c25683e8539f61314e848dd45c8ed">&#9670;&nbsp;</a></span>sparse_row_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1sparse__row__iterator.html">sparse_row_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::sparse_row_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>skip_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1sparse__row__iterator.html" title="An iterator that iterates over each element whose value does not equal the skip value.">Graph::sparse_row_iterator</a> pointing to beginning of the specified row </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index</td><td>Row index the returned iterator points to. </td></tr>
    <tr><td class="paramname">skip_data</td><td>Element values the iterator will skip over. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1sparse__row__iterator.html" title="An iterator that iterates over each element whose value does not equal the skip value.">Graph::sparse_row_iterator</a> pointing to the beginning of the row at index row_index. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,2) = 9;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,3) = 3;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;non-zero elements in row 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1sparse__row__iterator.html">Graph&lt;int&gt;::sparse_row_iterator</a> it = mygraph-&gt;<a class="code hl_function" href="class_graph.html#ac45c25683e8539f61314e848dd45c8ed">sparse_row_begin</a>(1, 0); it != mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_1_1sparse__row__iterator_html"><div class="ttname"><a href="class_graph_1_1sparse__row__iterator.html">Graph::sparse_row_iterator</a></div><div class="ttdoc">An iterator that iterates over each element whose value does not equal the skip value.</div><div class="ttdef"><b>Definition:</b> Graph.h:452</div></div>
<div class="ttc" id="aclass_graph_html_ac45c25683e8539f61314e848dd45c8ed"><div class="ttname"><a href="class_graph.html#ac45c25683e8539f61314e848dd45c8ed">Graph::sparse_row_begin</a></div><div class="ttdeci">virtual sparse_row_iterator sparse_row_begin(unsigned int row_index, const T &amp;skip_data)</div><div class="ttdoc">Returns a Graph::sparse_row_iterator pointing to beginning of the specified row</div><div class="ttdef"><b>Definition:</b> Graph.h:1567</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">non-zero elements in row 1: 1 9 3 </pre> <p ><b>Complexity</b></p>
<p >If the source dimension is dense, constant. Otherwise a binary search is used to find the beginning of a row.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if row_index is out of bounds of the source nodeset. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_graph_ac45c25683e8539f61314e848dd45c8ed_icgraph.png" border="0" usemap="#aclass_graph_ac45c25683e8539f61314e848dd45c8ed_icgraph" alt=""/></div>
<map name="aclass_graph_ac45c25683e8539f61314e848dd45c8ed_icgraph" id="aclass_graph_ac45c25683e8539f61314e848dd45c8ed_icgraph">
<area shape="rect" title="Returns a Graph::sparse_row_iterator pointing to beginning of the specified row" alt="" coords="433,148,603,175"/>
<area shape="rect" href="class_tasks.html#a76e4b13a54668969f96291652f678fb3" title="Function called after the communicate functions in a simulation cycle." alt="" coords="249,5,360,32"/>
<area shape="rect" href="structmedia__user.html#a86e1593193ee0aad0aa553daf0c476a0" title="Returns true if this user decides to follow an agent when called." alt="" coords="224,56,385,83"/>
<area shape="rect" href="structmedia__user.html#ab073845b9e391fc621cacdafb7c0f55e" title="The user adds a number of post events based on media_user::pdp." alt="" coords="231,107,378,149"/>
<area shape="rect" href="class_social___media.html#a5701c85fd5b4cbc00700026e94ea3a6b" title="Each users decides whether to unfollow any other user." alt="" coords="230,173,379,214"/>
<area shape="rect" href="class_location.html#a1ff84144cc863e5cad6ee600fa241aca" title="First function called in a simulation cycle." alt="" coords="251,239,358,265"/>
<area shape="rect" href="class_social___media.html#a692bdc21cbf7165820290fdfcecd39ce" title="Agents read events in their feed and create messages based on the read events." alt="" coords="237,289,373,316"/>
<area shape="rect" href="class_grand_interaction.html#a0892b33d56329bf3d31caebeb65b36a8" title="Function called after the #communicate functions in a simulation cycle." alt="" coords="5,5,176,32"/>
<area shape="rect" href="class_social___media.html#a289b460c2fde5969469a15893ae2bdf8" title="Feeds are updated, the social media will recommend users to follow, and users can decide to unfollow ..." alt="" coords="14,180,167,207"/>
</map>
</div>

</div>
</div>
<a id="a22dae102a7b8b502c8f1dffeecfbf107" name="a22dae102a7b8b502c8f1dffeecfbf107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dae102a7b8b502c8f1dffeecfbf107">&#9670;&nbsp;</a></span>sparse_row_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_graph_1_1const__sparse__row__iterator.html">const_sparse_row_iterator</a> <a class="el" href="class_graph.html">Graph</a>&lt; T &gt;::sparse_row_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>skip_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_graph_1_1const__sparse__row__iterator.html" title="A constant iterator that iterates over each element whose value does not equal the skip value.">Graph::const_sparse_row_iterator</a> pointing to beginning of the specified row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index</td><td>Row index the returned iterator points to. </td></tr>
    <tr><td class="paramname">skip_data</td><td>Element values the iterator will skip over. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph_1_1const__sparse__row__iterator.html">const_sparse_row_iterator</a> pointing to the beginning of the row at index row_index. </dd></dl>
<p ><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* mygraph;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Graph&lt;int&gt;* mygraph has been initialized with the following data</span></div>
<div class="line">    <span class="comment">// 0 1 4 2</span></div>
<div class="line">    <span class="comment">// 1 0 0 0</span></div>
<div class="line">    <span class="comment">// 0 0 2 3</span></div>
<div class="line">    <span class="comment">// 4 5 3 6</span></div>
<div class="line">    <span class="comment">// the default value for mygraph being zero.</span></div>
<div class="line">    <span class="comment">// each element with a zero does not have a data entry</span></div>
<div class="line"> </div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,2) = 9;</div>
<div class="line">    mygraph-&gt;<a class="code hl_function" href="class_graph.html#ae273f9fe0787d9140d32390db44513a0">at</a>(1,3) = 3;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_graph.html">Graph&lt;int&gt;</a>* const_mygraph = mygraph;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;non-zero elements in row 1:&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<a class="code hl_class" href="class_graph_1_1const__sparse__row__iterator.html">Graph&lt;int&gt;::const_sparse_row_iterator</a> it = const_mygraph-&gt;<a class="code hl_function" href="class_graph.html#ac45c25683e8539f61314e848dd45c8ed">sparse_row_begin</a>(1, 0); it != const_mygraph-&gt;end_row(1); ++it) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_graph_1_1const__sparse__row__iterator_html"><div class="ttname"><a href="class_graph_1_1const__sparse__row__iterator.html">Graph::const_sparse_row_iterator</a></div><div class="ttdoc">A constant iterator that iterates over each element whose value does not equal the skip value.</div><div class="ttdef"><b>Definition:</b> Graph.h:402</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">non-zero elements in row 1: 1 9 3 </pre> <p ><b>Complexity</b></p>
<p >If the source dimension is dense, constant. Otherwise a binary search is used to find the beginning of a row.</p>
<p ><b>Iterator validity</b></p>
<p >No changes.</p>
<p ><b>Exception Safety</b></p>
<p >An assertion is raised if row_index is out of bounds of the source nodeset. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_graph.html">Graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
